{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Shift Framework \u00b6","title":"Home"},{"location":"#welcome-to-shift-framework","text":"","title":"Welcome to Shift Framework"},{"location":"back-end/complete-api-setup/","text":"Complete The API Setup \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Installing The Packages \u00b6 Go to NuGet Package Manager and install these packages. Swashbuckle.AspNetCore Microsoft.AspNetCore.Components.WebAssembly.Server Setting Up Program.cs \u00b6 Go to Program.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web First, add the services like the below example: using Microsoft.EntityFrameworkCore ; var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }); var app = builder . Build (); app . Run (); Second, add the repository. using Microsoft.EntityFrameworkCore ; using ToDo.API.Data.Repositories ; var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }); builder . Services . AddScoped < ToDoRepository > (); var app = builder . Build (); app . Run (); After that, add the following codes to Program.cs : using Microsoft.EntityFrameworkCore ; using ToDo.API.Data.Repositories ; using ShiftSoftware.ShiftEntity.Web.Services ; var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }); builder . Services . AddScoped < ToDoRepository > (); builder . Services . AddSwaggerGen ( c => { c . DocInclusionPredicate ( SwaggerService . DocInclusionPredicate ); }); #if DEBUG builder . Services . AddRazorPages (); #endif var app = builder . Build (); #if DEBUG app . UseBlazorFrameworkFiles (); app . UseStaticFiles (); #endif app . MapControllers (); app . UseCors ( x => x . WithOrigins ( \"*\" ). AllowAnyMethod (). AllowAnyHeader ()); if ( app . Environment . IsDevelopment ()) { app . UseSwagger (); app . UseSwaggerUI (); } #if DEBUG app . MapRazorPages (); app . MapFallbackToFile ( \"index.html\" ); #endif app . Run (); Setting Up OData \u00b6 Inside Program.cs add the following code: using Microsoft.EntityFrameworkCore ; using ToDo.API.Data.Repositories ; using ShiftSoftware.ShiftEntity.Web.Services ; using Microsoft.OData.Edm ; using Microsoft.OData.ModelBuilder ; using Microsoft.AspNetCore.OData ; using ToDo.Shared.DTOs.ToDo ; using ToDo.API.Data ; static IEdmModel GetEdmModel () { var builder = new ODataConventionModelBuilder (); builder . EntitySet < ToDoListDTO > ( \"ToDo\" ); return builder . GetEdmModel (); } var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }); builder . Services . AddScoped < ToDoRepository > (); builder . Services . AddSwaggerGen ( c => { c . DocInclusionPredicate ( SwaggerService . DocInclusionPredicate ); }); #if DEBUG builder . Services . AddRazorPages (); #endif var app = builder . Build (); #if DEBUG app . UseBlazorFrameworkFiles (); app . UseStaticFiles (); #endif app . MapControllers (); app . UseCors ( x => x . WithOrigins ( \"*\" ). AllowAnyMethod (). AllowAnyHeader ()); if ( app . Environment . IsDevelopment ()) { app . UseSwagger (); app . UseSwaggerUI (); } #if DEBUG app . MapRazorPages (); app . MapFallbackToFile ( \"index.html\" ); #endif app . Run (); Then, add OData to Program.cs . using Microsoft.EntityFrameworkCore ; using ToDo.API.Data.Repositories ; using ShiftSoftware.ShiftEntity.Web.Services ; using Microsoft.OData.Edm ; using Microsoft.OData.ModelBuilder ; using Microsoft.AspNetCore.OData ; using ToDo.Shared.DTOs.ToDo ; using ToDo.API.Data ; static IEdmModel GetEdmModel () { var builder = new ODataConventionModelBuilder (); builder . EntitySet < ToDoListDTO > ( \"ToDo\" ); return builder . GetEdmModel (); } var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }) . AddOData ( opt => { opt . Count (). Filter (). Expand (). Select (). OrderBy (). SetMaxTop ( 1000 ) . AddRouteComponents ( \"odata\" , GetEdmModel ()); }); builder . Services . AddScoped < ToDoRepository > (); builder . Services . AddSwaggerGen ( c => { c . DocInclusionPredicate ( SwaggerService . DocInclusionPredicate ); }); #if DEBUG builder . Services . AddRazorPages (); #endif var app = builder . Build (); #if DEBUG app . UseBlazorFrameworkFiles (); app . UseStaticFiles (); #endif app . MapControllers (); app . UseCors ( x => x . WithOrigins ( \"*\" ). AllowAnyMethod (). AllowAnyHeader ()); if ( app . Environment . IsDevelopment ()) { app . UseSwagger (); app . UseSwaggerUI (); } #if DEBUG app . MapRazorPages (); app . MapFallbackToFile ( \"index.html\" ); #endif app . Run (); Setting Up The Database \u00b6 Add the database to the services. using Microsoft.EntityFrameworkCore ; using ToDo.API.Data.Repositories ; using ShiftSoftware.ShiftEntity.Web.Services ; using Microsoft.OData.Edm ; using Microsoft.OData.ModelBuilder ; using Microsoft.AspNetCore.OData ; using ToDo.Shared.DTOs.ToDo ; using ToDo.API.Data ; static IEdmModel GetEdmModel () { var builder = new ODataConventionModelBuilder (); builder . EntitySet < ToDoListDTO > ( \"ToDo\" ); return builder . GetEdmModel (); } var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddDbContext < DB > ( x => x . UseSqlServer ( builder . Configuration . GetConnectionString ( \"SQLServer\" ))) . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }) . AddOData ( opt => { opt . Count (). Filter (). Expand (). Select (). OrderBy (). SetMaxTop ( 1000 ) . AddRouteComponents ( \"odata\" , GetEdmModel ()); }); builder . Services . AddScoped < ToDoRepository > (); builder . Services . AddSwaggerGen ( c => { c . DocInclusionPredicate ( SwaggerService . DocInclusionPredicate ); }); #if DEBUG builder . Services . AddRazorPages (); #endif var app = builder . Build (); #if DEBUG app . UseBlazorFrameworkFiles (); app . UseStaticFiles (); #endif app . MapControllers (); app . UseCors ( x => x . WithOrigins ( \"*\" ). AllowAnyMethod (). AllowAnyHeader ()); if ( app . Environment . IsDevelopment ()) { app . UseSwagger (); app . UseSwaggerUI (); } #if DEBUG app . MapRazorPages (); app . MapFallbackToFile ( \"index.html\" ); #endif app . Run (); After that, go to appsettings.Development.json . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Add the connection strings like the following example: { \"ConnectionStrings\" : { \"SQLServer\" : \"Server=localhost\\\\sqlexpress;Initial Catalog=ToDo;Persist Security Info=True;Integrated Security=SSPI;TrustServerCertificate=True;\" }, \"Logging\" : { \"LogLevel\" : { \"Default\" : \"Information\" , \"Microsoft.AspNetCore\" : \"Warning\" } } } Lastly, open Package Manager Console and type the following commands: Add-Migration Init Update-Database Now, you can run the API and test it using Swagger.","title":"Completing API Setup"},{"location":"back-end/complete-api-setup/#complete-the-api-setup","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web","title":"Complete The API Setup"},{"location":"back-end/complete-api-setup/#installing-the-packages","text":"Go to NuGet Package Manager and install these packages. Swashbuckle.AspNetCore Microsoft.AspNetCore.Components.WebAssembly.Server","title":"Installing The Packages"},{"location":"back-end/complete-api-setup/#setting-up-programcs","text":"Go to Program.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web First, add the services like the below example: using Microsoft.EntityFrameworkCore ; var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }); var app = builder . Build (); app . Run (); Second, add the repository. using Microsoft.EntityFrameworkCore ; using ToDo.API.Data.Repositories ; var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }); builder . Services . AddScoped < ToDoRepository > (); var app = builder . Build (); app . Run (); After that, add the following codes to Program.cs : using Microsoft.EntityFrameworkCore ; using ToDo.API.Data.Repositories ; using ShiftSoftware.ShiftEntity.Web.Services ; var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }); builder . Services . AddScoped < ToDoRepository > (); builder . Services . AddSwaggerGen ( c => { c . DocInclusionPredicate ( SwaggerService . DocInclusionPredicate ); }); #if DEBUG builder . Services . AddRazorPages (); #endif var app = builder . Build (); #if DEBUG app . UseBlazorFrameworkFiles (); app . UseStaticFiles (); #endif app . MapControllers (); app . UseCors ( x => x . WithOrigins ( \"*\" ). AllowAnyMethod (). AllowAnyHeader ()); if ( app . Environment . IsDevelopment ()) { app . UseSwagger (); app . UseSwaggerUI (); } #if DEBUG app . MapRazorPages (); app . MapFallbackToFile ( \"index.html\" ); #endif app . Run ();","title":"Setting Up Program.cs"},{"location":"back-end/complete-api-setup/#setting-up-odata","text":"Inside Program.cs add the following code: using Microsoft.EntityFrameworkCore ; using ToDo.API.Data.Repositories ; using ShiftSoftware.ShiftEntity.Web.Services ; using Microsoft.OData.Edm ; using Microsoft.OData.ModelBuilder ; using Microsoft.AspNetCore.OData ; using ToDo.Shared.DTOs.ToDo ; using ToDo.API.Data ; static IEdmModel GetEdmModel () { var builder = new ODataConventionModelBuilder (); builder . EntitySet < ToDoListDTO > ( \"ToDo\" ); return builder . GetEdmModel (); } var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }); builder . Services . AddScoped < ToDoRepository > (); builder . Services . AddSwaggerGen ( c => { c . DocInclusionPredicate ( SwaggerService . DocInclusionPredicate ); }); #if DEBUG builder . Services . AddRazorPages (); #endif var app = builder . Build (); #if DEBUG app . UseBlazorFrameworkFiles (); app . UseStaticFiles (); #endif app . MapControllers (); app . UseCors ( x => x . WithOrigins ( \"*\" ). AllowAnyMethod (). AllowAnyHeader ()); if ( app . Environment . IsDevelopment ()) { app . UseSwagger (); app . UseSwaggerUI (); } #if DEBUG app . MapRazorPages (); app . MapFallbackToFile ( \"index.html\" ); #endif app . Run (); Then, add OData to Program.cs . using Microsoft.EntityFrameworkCore ; using ToDo.API.Data.Repositories ; using ShiftSoftware.ShiftEntity.Web.Services ; using Microsoft.OData.Edm ; using Microsoft.OData.ModelBuilder ; using Microsoft.AspNetCore.OData ; using ToDo.Shared.DTOs.ToDo ; using ToDo.API.Data ; static IEdmModel GetEdmModel () { var builder = new ODataConventionModelBuilder (); builder . EntitySet < ToDoListDTO > ( \"ToDo\" ); return builder . GetEdmModel (); } var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }) . AddOData ( opt => { opt . Count (). Filter (). Expand (). Select (). OrderBy (). SetMaxTop ( 1000 ) . AddRouteComponents ( \"odata\" , GetEdmModel ()); }); builder . Services . AddScoped < ToDoRepository > (); builder . Services . AddSwaggerGen ( c => { c . DocInclusionPredicate ( SwaggerService . DocInclusionPredicate ); }); #if DEBUG builder . Services . AddRazorPages (); #endif var app = builder . Build (); #if DEBUG app . UseBlazorFrameworkFiles (); app . UseStaticFiles (); #endif app . MapControllers (); app . UseCors ( x => x . WithOrigins ( \"*\" ). AllowAnyMethod (). AllowAnyHeader ()); if ( app . Environment . IsDevelopment ()) { app . UseSwagger (); app . UseSwaggerUI (); } #if DEBUG app . MapRazorPages (); app . MapFallbackToFile ( \"index.html\" ); #endif app . Run ();","title":"Setting Up OData"},{"location":"back-end/complete-api-setup/#setting-up-the-database","text":"Add the database to the services. using Microsoft.EntityFrameworkCore ; using ToDo.API.Data.Repositories ; using ShiftSoftware.ShiftEntity.Web.Services ; using Microsoft.OData.Edm ; using Microsoft.OData.ModelBuilder ; using Microsoft.AspNetCore.OData ; using ToDo.Shared.DTOs.ToDo ; using ToDo.API.Data ; static IEdmModel GetEdmModel () { var builder = new ODataConventionModelBuilder (); builder . EntitySet < ToDoListDTO > ( \"ToDo\" ); return builder . GetEdmModel (); } var builder = WebApplication . CreateBuilder ( args ); builder . Services . AddDbContext < DB > ( x => x . UseSqlServer ( builder . Configuration . GetConnectionString ( \"SQLServer\" ))) . AddControllers () . AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }) . AddOData ( opt => { opt . Count (). Filter (). Expand (). Select (). OrderBy (). SetMaxTop ( 1000 ) . AddRouteComponents ( \"odata\" , GetEdmModel ()); }); builder . Services . AddScoped < ToDoRepository > (); builder . Services . AddSwaggerGen ( c => { c . DocInclusionPredicate ( SwaggerService . DocInclusionPredicate ); }); #if DEBUG builder . Services . AddRazorPages (); #endif var app = builder . Build (); #if DEBUG app . UseBlazorFrameworkFiles (); app . UseStaticFiles (); #endif app . MapControllers (); app . UseCors ( x => x . WithOrigins ( \"*\" ). AllowAnyMethod (). AllowAnyHeader ()); if ( app . Environment . IsDevelopment ()) { app . UseSwagger (); app . UseSwaggerUI (); } #if DEBUG app . MapRazorPages (); app . MapFallbackToFile ( \"index.html\" ); #endif app . Run (); After that, go to appsettings.Development.json . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Add the connection strings like the following example: { \"ConnectionStrings\" : { \"SQLServer\" : \"Server=localhost\\\\sqlexpress;Initial Catalog=ToDo;Persist Security Info=True;Integrated Security=SSPI;TrustServerCertificate=True;\" }, \"Logging\" : { \"LogLevel\" : { \"Default\" : \"Information\" , \"Microsoft.AspNetCore\" : \"Warning\" } } } Lastly, open Package Manager Console and type the following commands: Add-Migration Init Update-Database Now, you can run the API and test it using Swagger.","title":"Setting Up The Database"},{"location":"back-end/controllers/","text":"Adding the Controllers \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Adding The Controller to Our API \u00b6 Inside Controllers folder, add a new class and name it ToDoController.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Then, add the route to the controller. using Microsoft.AspNetCore.Mvc ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController { } } After that, add ShiftEntityControllerAsync to the class and write the constructor. using Microsoft.AspNetCore.Mvc ; using ShiftSoftware.ShiftEntity.Web ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { public ToDoController ( ToDoRepository repository ) : base ( repository ) { } } }","title":"Controllers"},{"location":"back-end/controllers/#adding-the-controllers","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web","title":"Adding the Controllers"},{"location":"back-end/controllers/#adding-the-controller-to-our-api","text":"Inside Controllers folder, add a new class and name it ToDoController.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Then, add the route to the controller. using Microsoft.AspNetCore.Mvc ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController { } } After that, add ShiftEntityControllerAsync to the class and write the constructor. using Microsoft.AspNetCore.Mvc ; using ShiftSoftware.ShiftEntity.Web ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { public ToDoController ( ToDoRepository repository ) : base ( repository ) { } } }","title":"Adding The Controller to Our API"},{"location":"back-end/dtos/","text":"Adding DTOs to ToDo.Shared \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 DTOs \u2502 \u251c\u2500\u2500 Enums \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Installing The Packages \u00b6 Open NuGet Package Manager for the ToDo.Shared project and install ShiftSoftware.ShiftEntity.Model package. Creating The Classes \u00b6 First, go to ToDo.Shared project and right-click on DTOs folder, select Add -> New Folder and name it ToDo . Inside ToDo folder, add a class by right-clicking on the ToDo folder and name it ToDoDTO.cs . Then, inside the same folder, add another class and name it ToDoListDTO.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 DTOs \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoDTO.cs \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoListDTO.cs \u2502 \u251c\u2500\u2500 Enums \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web After that, inside the Enums folder, add a class and name it ToDoStatus.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 DTOs \u2502 \u251c\u2500\u2500 Enums \u2502 \u2502 \u251c\u2500\u2500 ToDoStatus.cs \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web In the class, change the class to enum and internal to public like the following example: namespace ToDo.Shared.Enums ; public enum ToDoStatus { } Change internal to public inside the DTOs too. ToDoDTO.cs : namespace ToDo.Shared.DTOs.ToDo ; public class ToDoDTO { } ToDoListDTO.cs : namespace ToDo.Shared.DTOs.ToDo ; public class ToDoListDTO { } Adding Properties to Our Classes \u00b6 Inside ToDoStatus.cs add the follwoing enums: namespace ToDo.Shared.Enums ; public enum ToDoStatus { New = 1 , InProgress = 2 , Completed = 3 } After that, inside ToDoDTO.cs add the following properties to the class: using ShiftSoftware.ShiftEntity.Model.Dtos ; using System.Text.Json.Serialization ; using ToDo.Shared.Enums ; namespace ToDo.Shared.DTOs.ToDo ; public class ToDoDTO { public override string? ID { get ; set ; } public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; [JsonConverter(typeof(JsonStringEnumConverter))] public ToDoStatus Status { get ; set ; } } Then, inside ToDoListDTO.cs add the following properties to the class: using ShiftSoftware.ShiftEntity.Model.Dtos ; using System.Text.Json.Serialization ; using ToDo.Shared.Enums ; namespace ToDo.Shared.DTOs.ToDo ; public class ToDoListDTO { public override string? ID { get ; set ; } public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; [JsonConverter(typeof(JsonStringEnumConverter))] public ToDoStatus Status { get ; set ; } } Adding Shift Entity DTO to Our Classes \u00b6 First, go to NuGet Package Manager and install the latest version of ShiftSoftware.ShiftEntity.Model . Then, go to ToDoDTO.cs and add the following code: using ShiftSoftware.ShiftEntity.Model.Dtos ; using System.Text.Json.Serialization ; using ToDo.Shared.Enums ; namespace ToDo.Shared.DTOs.ToDo ; public class ToDoDTO : ShiftEntityDTO { public override string? ID { get ; set ; } public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; [JsonConverter(typeof(JsonStringEnumConverter))] public ToDoStatus Status { get ; set ; } } Inside ToDoListDTO.cs add the following code: using ShiftSoftware.ShiftEntity.Model.Dtos ; using System.Text.Json.Serialization ; using ToDo.Shared.Enums ; namespace ToDo.Shared.DTOs.ToDo ; public class ToDoListDTO : ShiftEntityListDTO { public override string? ID { get ; set ; } public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; [JsonConverter(typeof(JsonStringEnumConverter))] public ToDoStatus Status { get ; set ; } }","title":"DTOs"},{"location":"back-end/dtos/#adding-dtos-to-todoshared","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 DTOs \u2502 \u251c\u2500\u2500 Enums \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web","title":"Adding DTOs to ToDo.Shared"},{"location":"back-end/dtos/#installing-the-packages","text":"Open NuGet Package Manager for the ToDo.Shared project and install ShiftSoftware.ShiftEntity.Model package.","title":"Installing The Packages"},{"location":"back-end/dtos/#creating-the-classes","text":"First, go to ToDo.Shared project and right-click on DTOs folder, select Add -> New Folder and name it ToDo . Inside ToDo folder, add a class by right-clicking on the ToDo folder and name it ToDoDTO.cs . Then, inside the same folder, add another class and name it ToDoListDTO.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 DTOs \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoDTO.cs \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoListDTO.cs \u2502 \u251c\u2500\u2500 Enums \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web After that, inside the Enums folder, add a class and name it ToDoStatus.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 DTOs \u2502 \u251c\u2500\u2500 Enums \u2502 \u2502 \u251c\u2500\u2500 ToDoStatus.cs \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web In the class, change the class to enum and internal to public like the following example: namespace ToDo.Shared.Enums ; public enum ToDoStatus { } Change internal to public inside the DTOs too. ToDoDTO.cs : namespace ToDo.Shared.DTOs.ToDo ; public class ToDoDTO { } ToDoListDTO.cs : namespace ToDo.Shared.DTOs.ToDo ; public class ToDoListDTO { }","title":"Creating The Classes"},{"location":"back-end/dtos/#adding-properties-to-our-classes","text":"Inside ToDoStatus.cs add the follwoing enums: namespace ToDo.Shared.Enums ; public enum ToDoStatus { New = 1 , InProgress = 2 , Completed = 3 } After that, inside ToDoDTO.cs add the following properties to the class: using ShiftSoftware.ShiftEntity.Model.Dtos ; using System.Text.Json.Serialization ; using ToDo.Shared.Enums ; namespace ToDo.Shared.DTOs.ToDo ; public class ToDoDTO { public override string? ID { get ; set ; } public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; [JsonConverter(typeof(JsonStringEnumConverter))] public ToDoStatus Status { get ; set ; } } Then, inside ToDoListDTO.cs add the following properties to the class: using ShiftSoftware.ShiftEntity.Model.Dtos ; using System.Text.Json.Serialization ; using ToDo.Shared.Enums ; namespace ToDo.Shared.DTOs.ToDo ; public class ToDoListDTO { public override string? ID { get ; set ; } public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; [JsonConverter(typeof(JsonStringEnumConverter))] public ToDoStatus Status { get ; set ; } }","title":"Adding Properties to Our Classes"},{"location":"back-end/dtos/#adding-shift-entity-dto-to-our-classes","text":"First, go to NuGet Package Manager and install the latest version of ShiftSoftware.ShiftEntity.Model . Then, go to ToDoDTO.cs and add the following code: using ShiftSoftware.ShiftEntity.Model.Dtos ; using System.Text.Json.Serialization ; using ToDo.Shared.Enums ; namespace ToDo.Shared.DTOs.ToDo ; public class ToDoDTO : ShiftEntityDTO { public override string? ID { get ; set ; } public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; [JsonConverter(typeof(JsonStringEnumConverter))] public ToDoStatus Status { get ; set ; } } Inside ToDoListDTO.cs add the following code: using ShiftSoftware.ShiftEntity.Model.Dtos ; using System.Text.Json.Serialization ; using ToDo.Shared.Enums ; namespace ToDo.Shared.DTOs.ToDo ; public class ToDoListDTO : ShiftEntityListDTO { public override string? ID { get ; set ; } public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; [JsonConverter(typeof(JsonStringEnumConverter))] public ToDoStatus Status { get ; set ; } }","title":"Adding Shift Entity DTO to Our Classes"},{"location":"back-end/entities/","text":"Using Shift Entities \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Installing The Packages \u00b6 Go to NuGet Package Manager and install the following two packages: ShiftSoftware.ShiftEntity.Web Microsoft.EntityFrameworkCore.Tools Adding Entities To Our API \u00b6 Right-click on Data/Entities folder and add a new class named ToDo.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Then, add the following properties to the class: using ToDo.Shared.Enums ; namespace ToDo.API.Data.Entities ; public class ToDo { public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; public ToDoStatus Status { get ; set ; } } After that, add ShiftEntity and TemporalShiftEntity to the class. using ShiftSoftware.ShiftEntity.Core ; using ToDo.Shared.Enums ; namespace ToDo.API.Data.Entities ; [TemporalShiftEntity] public class ToDo : ShiftEntity < ToDo > { public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; public ToDoStatus Status { get ; set ; } } Lastly, add the following two operators to the class: using ShiftSoftware.ShiftEntity.Core ; using ToDo.Shared.DTOs.ToDo ; using ToDo.Shared.Enums ; namespace ToDo.API.Data.Entities ; [TemporalShiftEntity] public class ToDo : ShiftEntity < ToDo > { public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; public ToDoStatus Status { get ; set ; } public static implicit operator ToDoDTO ( ToDo entity ) { if ( entity == null ) return default ! ; return new ToDoDTO { CreateDate = entity . CreateDate , CreatedByUserID = entity . CreatedByUserID . ToString (), IsDeleted = entity . IsDeleted , LastSaveDate = entity . LastSaveDate , LastSavedByUserID = entity . LastSavedByUserID . ToString (), ID = entity . ID . ToString (), Description = entity . Description , Status = entity . Status , Title = entity . Title , }; } public static implicit operator ToDoListDTO ( ToDo entity ) { if ( entity == null ) return default ! ; return new ToDoListDTO { ID = entity . ID . ToString (), Description = entity . Description , Status = entity . Status , Title = entity . Title , }; } } Adding The Database \u00b6 Inside Data folder add a new class and name it DB.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Then, add ShiftDbConetxt to the class and write the constructor. using Microsoft.EntityFrameworkCore ; using ShiftSoftware.ShiftEntity.Core ; namespace ToDo.API.Data { public class DB : ShiftDbContext { public DB ( DbContextOptions option ) : base ( option ) { } } } After that, add the following property: using Microsoft.EntityFrameworkCore ; using ShiftSoftware.ShiftEntity.Core ; namespace ToDo.API.Data { public class DB : ShiftDbContext { public DB ( DbContextOptions option ) : base ( option ) { } public DbSet < Entities . ToDo > ToDos { get ; set ; } } }","title":"Entities"},{"location":"back-end/entities/#using-shift-entities","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web","title":"Using Shift Entities"},{"location":"back-end/entities/#installing-the-packages","text":"Go to NuGet Package Manager and install the following two packages: ShiftSoftware.ShiftEntity.Web Microsoft.EntityFrameworkCore.Tools","title":"Installing The Packages"},{"location":"back-end/entities/#adding-entities-to-our-api","text":"Right-click on Data/Entities folder and add a new class named ToDo.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Then, add the following properties to the class: using ToDo.Shared.Enums ; namespace ToDo.API.Data.Entities ; public class ToDo { public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; public ToDoStatus Status { get ; set ; } } After that, add ShiftEntity and TemporalShiftEntity to the class. using ShiftSoftware.ShiftEntity.Core ; using ToDo.Shared.Enums ; namespace ToDo.API.Data.Entities ; [TemporalShiftEntity] public class ToDo : ShiftEntity < ToDo > { public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; public ToDoStatus Status { get ; set ; } } Lastly, add the following two operators to the class: using ShiftSoftware.ShiftEntity.Core ; using ToDo.Shared.DTOs.ToDo ; using ToDo.Shared.Enums ; namespace ToDo.API.Data.Entities ; [TemporalShiftEntity] public class ToDo : ShiftEntity < ToDo > { public string Title { get ; set ; } = default ! ; public string Description { get ; set ; } = default ! ; public ToDoStatus Status { get ; set ; } public static implicit operator ToDoDTO ( ToDo entity ) { if ( entity == null ) return default ! ; return new ToDoDTO { CreateDate = entity . CreateDate , CreatedByUserID = entity . CreatedByUserID . ToString (), IsDeleted = entity . IsDeleted , LastSaveDate = entity . LastSaveDate , LastSavedByUserID = entity . LastSavedByUserID . ToString (), ID = entity . ID . ToString (), Description = entity . Description , Status = entity . Status , Title = entity . Title , }; } public static implicit operator ToDoListDTO ( ToDo entity ) { if ( entity == null ) return default ! ; return new ToDoListDTO { ID = entity . ID . ToString (), Description = entity . Description , Status = entity . Status , Title = entity . Title , }; } }","title":"Adding Entities To Our API"},{"location":"back-end/entities/#adding-the-database","text":"Inside Data folder add a new class and name it DB.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Then, add ShiftDbConetxt to the class and write the constructor. using Microsoft.EntityFrameworkCore ; using ShiftSoftware.ShiftEntity.Core ; namespace ToDo.API.Data { public class DB : ShiftDbContext { public DB ( DbContextOptions option ) : base ( option ) { } } } After that, add the following property: using Microsoft.EntityFrameworkCore ; using ShiftSoftware.ShiftEntity.Core ; namespace ToDo.API.Data { public class DB : ShiftDbContext { public DB ( DbContextOptions option ) : base ( option ) { } public DbSet < Entities . ToDo > ToDos { get ; set ; } } }","title":"Adding The Database"},{"location":"back-end/getting-started/","text":"Getting Started with Shift Framework for Back-end Development \u00b6 Setting Up The Project \u00b6 Open Visual Studio and create a new ASP.NET Core Empty project, and write the Project Name as ToDo.API and the Solution Name as ToDo . After clicking Next , untick Configure for HTTPS option (Untick this option for all the project you create throughout this tutorial) and create the project. The project file structure should look like this: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs Then, create the following projects inside the same solution by right-clicking on the project solution and selecting Add -> New Project : Class Library , name it ToDo.Shared . xUnit Test Project , name it ToDo.Test . Blazor WebAssembly App Empty , name it ToDo.Web . If you want to know how to create the rest of the projects, please follow these steps: right-click on the project solutions and select Add -> New Project . Add a Class Library project and name it ToDo.Shared . right-click on the project solutions again and select Add -> New Project . Add a xUnit Test Project project and name it ToDo.Test . right-click on the project solutions again and select Add -> New Project . Add a Blazor WebAssembly App Empty project and name it ToDo.Web . After clicking Next , untick Configure for HTTPS option and create the project. The project file structure should look like this: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 Program.cs Adding The Project References \u00b6 Go to ToDo.API and right-click on Dependencies , then select Add Project Reference.. . Then tick ToDo.Shared and ToDo.Web projects and click OK . ToDo.Shared ToDo.Test ToDo.Web For ToDo.Test , tick ToDo.API . ToDo.API ToDo.Shared ToDo.Web For ToDo.Web , tick ToDo.Shared . ToDo.API ToDo.Shared ToDo.Test Adding The Needed Folders \u00b6 Right-click on ToDo.API project and select Add -> New Folder , then add the following folders: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Inside ToDo.Shared add the following folders: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 DTOs \u2502 \u251c\u2500\u2500 Enums \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Inside ToDo.Web add the following folders: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 Program.cs","title":"Getting Started"},{"location":"back-end/getting-started/#getting-started-with-shift-framework-for-back-end-development","text":"","title":"Getting Started with Shift Framework for Back-end Development"},{"location":"back-end/getting-started/#setting-up-the-project","text":"Open Visual Studio and create a new ASP.NET Core Empty project, and write the Project Name as ToDo.API and the Solution Name as ToDo . After clicking Next , untick Configure for HTTPS option (Untick this option for all the project you create throughout this tutorial) and create the project. The project file structure should look like this: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs Then, create the following projects inside the same solution by right-clicking on the project solution and selecting Add -> New Project : Class Library , name it ToDo.Shared . xUnit Test Project , name it ToDo.Test . Blazor WebAssembly App Empty , name it ToDo.Web . If you want to know how to create the rest of the projects, please follow these steps: right-click on the project solutions and select Add -> New Project . Add a Class Library project and name it ToDo.Shared . right-click on the project solutions again and select Add -> New Project . Add a xUnit Test Project project and name it ToDo.Test . right-click on the project solutions again and select Add -> New Project . Add a Blazor WebAssembly App Empty project and name it ToDo.Web . After clicking Next , untick Configure for HTTPS option and create the project. The project file structure should look like this: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 Program.cs","title":"Setting Up The Project"},{"location":"back-end/getting-started/#adding-the-project-references","text":"Go to ToDo.API and right-click on Dependencies , then select Add Project Reference.. . Then tick ToDo.Shared and ToDo.Web projects and click OK . ToDo.Shared ToDo.Test ToDo.Web For ToDo.Test , tick ToDo.API . ToDo.API ToDo.Shared ToDo.Web For ToDo.Web , tick ToDo.Shared . ToDo.API ToDo.Shared ToDo.Test","title":"Adding The Project References"},{"location":"back-end/getting-started/#adding-the-needed-folders","text":"Right-click on ToDo.API project and select Add -> New Folder , then add the following folders: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Inside ToDo.Shared add the following folders: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 DTOs \u2502 \u251c\u2500\u2500 Enums \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Inside ToDo.Web add the following folders: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 Program.cs","title":"Adding The Needed Folders"},{"location":"back-end/odata/","text":"Setting Up OData on the Project \u00b6 Before we create the repositories, we need to set up OData on our project. So, the first step is to install ShiftSoftware.ShiftEntity.Web using Nuget Package Manager, or using the following command line in the .NET CLI. dotnet add package ShiftSoftware.ShiftEntity.Web --version 1 .3.13-alpha Second, we need to create the EDM model inside Program.cs . static IEdmModel GetEdmModel () { var builder = new ODataConventionModelBuilder (); builder . EntitySet < ToDoListDTO > ( \"ToDo\" ); return builder . GetEdmModel (); } var builder = WebApplication . CreateBuilder ( args ); Then, we add Json options to our controller inside Program.cs . // Add services to the container. builder . Services . AddDbContext < DB > ( x => x . UseSqlServer ( builder . Configuration . GetConnectionString ( \"SQLServer\" ))); builder . Services . AddControllers (). AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }); After that, we will add OData to the controllers. // Add services to the container. builder . Services . AddDbContext < DB > ( x => x . UseSqlServer ( builder . Configuration . GetConnectionString ( \"SQLServer\" ))); builder . Services . AddControllers (). AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }) . AddOData ( opt => { opt . Count (). Filter (). Expand (). Select (). OrderBy (). SetMaxTop ( 1000 ) . AddRouteComponents ( \"odata\" , GetEdmModel ()); });","title":"Setting Up OData on the Project"},{"location":"back-end/odata/#setting-up-odata-on-the-project","text":"Before we create the repositories, we need to set up OData on our project. So, the first step is to install ShiftSoftware.ShiftEntity.Web using Nuget Package Manager, or using the following command line in the .NET CLI. dotnet add package ShiftSoftware.ShiftEntity.Web --version 1 .3.13-alpha Second, we need to create the EDM model inside Program.cs . static IEdmModel GetEdmModel () { var builder = new ODataConventionModelBuilder (); builder . EntitySet < ToDoListDTO > ( \"ToDo\" ); return builder . GetEdmModel (); } var builder = WebApplication . CreateBuilder ( args ); Then, we add Json options to our controller inside Program.cs . // Add services to the container. builder . Services . AddDbContext < DB > ( x => x . UseSqlServer ( builder . Configuration . GetConnectionString ( \"SQLServer\" ))); builder . Services . AddControllers (). AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }); After that, we will add OData to the controllers. // Add services to the container. builder . Services . AddDbContext < DB > ( x => x . UseSqlServer ( builder . Configuration . GetConnectionString ( \"SQLServer\" ))); builder . Services . AddControllers (). AddJsonOptions ( options => { options . JsonSerializerOptions . PropertyNamingPolicy = null ; }) . AddOData ( opt => { opt . Count (). Filter (). Expand (). Select (). OrderBy (). SetMaxTop ( 1000 ) . AddRouteComponents ( \"odata\" , GetEdmModel ()); });","title":"Setting Up OData on the Project"},{"location":"back-end/repositories/","text":"Adding Shift Repositories \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Adding Repositories To Our API \u00b6 Inside Data/Repositories folder add a class and name it ToDoRepository.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web In the class, add ShiftRepository and IShiftRepositoryAsync to the class like the example below: using ShiftSoftware.ShiftEntity.Core ; using ToDo.API.Data.Entities ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Data.Repositories { public class ToDoRepository : ShiftRepository < Entities . ToDo > , IShiftRepositoryAsync < Entities . ToDo , ToDoListDTO , ToDoDTO > { } } After that, write the constructor and implement Shift Interface methods. using ShiftSoftware.ShiftEntity.Core ; using ToDo.API.Data.Entities ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Data.Repositories { public class ToDoRepository : ShiftRepository < Entities . ToDo > , IShiftRepositoryAsync < Entities . ToDo , ToDoListDTO , ToDoDTO > { public ToDoRepository ( DB db ) : base ( db , db . ToDos ) { } public Task < Entities . ToDo > CreateAsync ( ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public Task < Entities . ToDo > DeleteAsync ( Entities . ToDo entity , long? userId = null ) { throw new NotImplementedException (); } public Task < Entities . ToDo > FindAsync ( long id , DateTime ? asOf = null , bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public IQueryable < ToDoListDTO > OdataList ( bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public Task < Entities . ToDo > UpdateAsync ( Entities . ToDo entity , ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public Task < ToDoDTO > ViewAsync ( Entities . ToDo entity ) { throw new NotImplementedException (); } } } Then, add database property and change the methods to asynchronous. using Microsoft.EntityFrameworkCore ; using ShiftSoftware.ShiftEntity.Core ; using ToDo.API.Data.Entities ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Data.Repositories { public class ToDoRepository : ShiftRepository < Entities . ToDo > , IShiftRepositoryAsync < Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoRepository ( DB db ) : base ( db , db . ToDos ) { this . db = db ; } public async Task < Entities . ToDo > CreateAsync ( ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > DeleteAsync ( Entities . ToDo entity , long? userId = null ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > FindAsync ( long id , DateTime ? asOf = null , bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public async IQueryable < ToDoListDTO > OdataList ( bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > UpdateAsync ( Entities . ToDo entity , ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public async Task < ToDoDTO > ViewAsync ( Entities . ToDo entity ) { throw new NotImplementedException (); } } } After that, add the following method: using Microsoft.EntityFrameworkCore ; using ShiftSoftware.ShiftEntity.Core ; using ToDo.API.Data.Entities ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Data.Repositories { public class ToDoRepository : ShiftRepository < Entities . ToDo > , IShiftRepositoryAsync < Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoRepository ( DB db ) : base ( db , db . ToDos ) { this . db = db ; } public async Task < Entities . ToDo > CreateAsync ( ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > DeleteAsync ( Entities . ToDo entity , long? userId = null ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > FindAsync ( long id , DateTime ? asOf = null , bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public async IQueryable < ToDoListDTO > OdataList ( bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > UpdateAsync ( Entities . ToDo entity , ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public async Task < ToDoDTO > ViewAsync ( Entities . ToDo entity ) { throw new NotImplementedException (); } public async Task AssignValue ( Entities . ToDo entity , ToDoDTO dto ) { entity . Title = dto . Title ; entity . Description = dto . Description ; entity . Status = dto . Status ; } } } Now, start the methods like the example below: using Microsoft.EntityFrameworkCore ; using ShiftSoftware.ShiftEntity.Core ; using ToDo.API.Data.Entities ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Data.Repositories { public class ToDoRepository : ShiftRepository < Entities . ToDo > , IShiftRepositoryAsync < Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoRepository ( DB db ) : base ( db , db . ToDos ) { this . db = db ; } public async Task < Entities . ToDo > CreateAsync ( ToDoDTO dto , long? userId = null ) { var entity = new Entities . ToDo (). CreateShiftEntity ( userId ); await this . AssignValue ( entity , dto ); return entity ; } public async Task < Entities . ToDo > DeleteAsync ( Entities . ToDo entity , long? userId = null ) { entity . DeleteShiftEntity ( userId ); return entity ; } public async Task < Entities . ToDo > FindAsync ( long id , DateTime ? asOf = null , bool ignoreGlobalFilters = false ) { return await base . FindAsync ( id , asOf , ignoreGlobalFilters ); } public IQueryable < ToDoListDTO > OdataList ( bool ignoreGlobalFilters = false ) { return this . db . ToDos . Select ( x => ( ToDoListDTO ) x ); } public async Task < Entities . ToDo > UpdateAsync ( Entities . ToDo entity , ToDoDTO dto , long? userId = null ) { entity . UpdateShiftEntity ( userId ); await this . AssignValue ( entity , dto ); return entity ; } public async Task < ToDoDTO > ViewAsync ( Entities . ToDo entity ) { return entity ; } public async Task AssignValue ( Entities . ToDo entity , ToDoDTO dto ) { entity . Title = dto . Title ; entity . Description = dto . Description ; entity . Status = dto . Status ; } } }","title":"Repositories"},{"location":"back-end/repositories/#adding-shift-repositories","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web","title":"Adding Shift Repositories"},{"location":"back-end/repositories/#adding-repositories-to-our-api","text":"Inside Data/Repositories folder add a class and name it ToDoRepository.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web In the class, add ShiftRepository and IShiftRepositoryAsync to the class like the example below: using ShiftSoftware.ShiftEntity.Core ; using ToDo.API.Data.Entities ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Data.Repositories { public class ToDoRepository : ShiftRepository < Entities . ToDo > , IShiftRepositoryAsync < Entities . ToDo , ToDoListDTO , ToDoDTO > { } } After that, write the constructor and implement Shift Interface methods. using ShiftSoftware.ShiftEntity.Core ; using ToDo.API.Data.Entities ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Data.Repositories { public class ToDoRepository : ShiftRepository < Entities . ToDo > , IShiftRepositoryAsync < Entities . ToDo , ToDoListDTO , ToDoDTO > { public ToDoRepository ( DB db ) : base ( db , db . ToDos ) { } public Task < Entities . ToDo > CreateAsync ( ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public Task < Entities . ToDo > DeleteAsync ( Entities . ToDo entity , long? userId = null ) { throw new NotImplementedException (); } public Task < Entities . ToDo > FindAsync ( long id , DateTime ? asOf = null , bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public IQueryable < ToDoListDTO > OdataList ( bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public Task < Entities . ToDo > UpdateAsync ( Entities . ToDo entity , ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public Task < ToDoDTO > ViewAsync ( Entities . ToDo entity ) { throw new NotImplementedException (); } } } Then, add database property and change the methods to asynchronous. using Microsoft.EntityFrameworkCore ; using ShiftSoftware.ShiftEntity.Core ; using ToDo.API.Data.Entities ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Data.Repositories { public class ToDoRepository : ShiftRepository < Entities . ToDo > , IShiftRepositoryAsync < Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoRepository ( DB db ) : base ( db , db . ToDos ) { this . db = db ; } public async Task < Entities . ToDo > CreateAsync ( ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > DeleteAsync ( Entities . ToDo entity , long? userId = null ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > FindAsync ( long id , DateTime ? asOf = null , bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public async IQueryable < ToDoListDTO > OdataList ( bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > UpdateAsync ( Entities . ToDo entity , ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public async Task < ToDoDTO > ViewAsync ( Entities . ToDo entity ) { throw new NotImplementedException (); } } } After that, add the following method: using Microsoft.EntityFrameworkCore ; using ShiftSoftware.ShiftEntity.Core ; using ToDo.API.Data.Entities ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Data.Repositories { public class ToDoRepository : ShiftRepository < Entities . ToDo > , IShiftRepositoryAsync < Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoRepository ( DB db ) : base ( db , db . ToDos ) { this . db = db ; } public async Task < Entities . ToDo > CreateAsync ( ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > DeleteAsync ( Entities . ToDo entity , long? userId = null ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > FindAsync ( long id , DateTime ? asOf = null , bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public async IQueryable < ToDoListDTO > OdataList ( bool ignoreGlobalFilters = false ) { throw new NotImplementedException (); } public async Task < Entities . ToDo > UpdateAsync ( Entities . ToDo entity , ToDoDTO dto , long? userId = null ) { throw new NotImplementedException (); } public async Task < ToDoDTO > ViewAsync ( Entities . ToDo entity ) { throw new NotImplementedException (); } public async Task AssignValue ( Entities . ToDo entity , ToDoDTO dto ) { entity . Title = dto . Title ; entity . Description = dto . Description ; entity . Status = dto . Status ; } } } Now, start the methods like the example below: using Microsoft.EntityFrameworkCore ; using ShiftSoftware.ShiftEntity.Core ; using ToDo.API.Data.Entities ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Data.Repositories { public class ToDoRepository : ShiftRepository < Entities . ToDo > , IShiftRepositoryAsync < Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoRepository ( DB db ) : base ( db , db . ToDos ) { this . db = db ; } public async Task < Entities . ToDo > CreateAsync ( ToDoDTO dto , long? userId = null ) { var entity = new Entities . ToDo (). CreateShiftEntity ( userId ); await this . AssignValue ( entity , dto ); return entity ; } public async Task < Entities . ToDo > DeleteAsync ( Entities . ToDo entity , long? userId = null ) { entity . DeleteShiftEntity ( userId ); return entity ; } public async Task < Entities . ToDo > FindAsync ( long id , DateTime ? asOf = null , bool ignoreGlobalFilters = false ) { return await base . FindAsync ( id , asOf , ignoreGlobalFilters ); } public IQueryable < ToDoListDTO > OdataList ( bool ignoreGlobalFilters = false ) { return this . db . ToDos . Select ( x => ( ToDoListDTO ) x ); } public async Task < Entities . ToDo > UpdateAsync ( Entities . ToDo entity , ToDoDTO dto , long? userId = null ) { entity . UpdateShiftEntity ( userId ); await this . AssignValue ( entity , dto ); return entity ; } public async Task < ToDoDTO > ViewAsync ( Entities . ToDo entity ) { return entity ; } public async Task AssignValue ( Entities . ToDo entity , ToDoDTO dto ) { entity . Title = dto . Title ; entity . Description = dto . Description ; entity . Status = dto . Status ; } } }","title":"Adding Repositories To Our API"},{"location":"back-end/testing/","text":"Testing \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web Installing The Packages \u00b6 Open NuGet Package Manager and install the following two packages for the project: Microsoft.AspNetCore.Mvc.Testing Microsoft.EntityFrameworkCore Setting Up The Test Project Files \u00b6 Create a new folder inside the project and name it Tests . Inside that folder, create a new one and name it ToDo . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Tests \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web Inside Usings.cs add the following code: global using Xunit ; global using System.Text.Json ; global using ShiftSoftware.ShiftEntity.Model ; global using System.Text.Json.Nodes ; global using System.Text ; global using Xunit.Abstractions ; global using ToDo.Shared ; global using ToDo.API ; Then, go to ToDo.API Project. ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Add a new class inside the project and name it WebMarker.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web After that, go back to ToDo.Test project. ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Tests \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web Now, we will add three classes inside the project, BasicTest.CS , CustomWebApplicationFactory.cs , TestPriorityAttribute.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Tests \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u251c\u2500\u2500 BasicTest.cs \u2502 \u251c\u2500\u2500 CustomWebApplicationFactory.cs \u2502 \u251c\u2500\u2500 TestPriorityAttribute.cs \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web First, copy the code below and paste the whole code inside BasicTest.cs . using ShiftSoftware.ShiftEntity.Model.Dtos ; using ShiftSoftware.ShiftEntity.Model ; using System.Text.Json.Nodes ; using System.Text ; using Xunit.Abstractions ; namespace ToDo.Test ; public class BasicTest < DTO , ListDTO > where DTO : ShiftEntityDTO where ListDTO : ShiftEntityListDTO { public HttpClient client ; public ITestOutputHelper output ; public string ApiItemName { get ; set ; } public string OdataItemName { get ; set ; } public BasicTest ( string apiItemName , string odataItemItem , HttpClient client , ITestOutputHelper output ) { this . ApiItemName = apiItemName ; this . OdataItemName = odataItemItem ; this . client = client ; this . output = output ; } public async Task < DTO > Get ( long ID , bool ensureSuccessStatusCode = true ) { HttpResponseMessage obj = await client . GetAsync ( $\"/api/{ApiItemName}/{ID}\" ); var text = await obj . Content . ReadAsStringAsync (); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var item = JsonNode . Parse ( text ). Deserialize < ShiftEntityResponse < DTO >> (); return item ! . Entity ! ; } public async Task < DTO > Post ( DTO dto , bool ensureSuccessStatusCode = true ) { var httpContent = new StringContent ( JsonSerializer . Serialize ( dto ), Encoding . UTF8 , \"application/json\" ); HttpResponseMessage obj = await client . PostAsync ( $\"/api/{ApiItemName}\" , httpContent ); var text = await obj . Content . ReadAsStringAsync (); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var item = JsonNode . Parse ( text ). Deserialize < ShiftEntityResponse < DTO >> (); return item ! . Entity ! ; } public async Task < DTO > Put ( long ID , DTO dto , bool ensureSuccessStatusCode = true ) { var httpContent = new StringContent ( JsonSerializer . Serialize ( dto ), Encoding . UTF8 , \"application/json\" ); HttpResponseMessage obj = await client . PutAsync ( $\"/api/{ApiItemName}/{ID}\" , httpContent ); var text = await obj . Content . ReadAsStringAsync (); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var item = JsonNode . Parse ( text ). Deserialize < ShiftEntityResponse < DTO >> (); return item ! . Entity ! ; } public async Task < DTO > Delete ( long ID , bool ensureSuccessStatusCode = true ) { HttpResponseMessage obj = await client . DeleteAsync ( $\"/api/{ApiItemName}/{ID}\" ); var text = await obj . Content . ReadAsStringAsync (); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var item = JsonNode . Parse ( text ). Deserialize < ShiftEntityResponse < DTO >> (); return item ! . Entity ! ; } public async Task < List < ListDTO >> OdataList ( string? queryString = null , bool ensureSuccessStatusCode = true ) { HttpResponseMessage obj = await client . GetAsync ( $\"/odata/{OdataItemName}{queryString}\" ); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var text = await obj . Content . ReadAsStringAsync (); var items = JsonNode . Parse ( text ) ! [ \"value\" ]. Deserialize < List < ListDTO >> (); return items ! ; } public async Task < List < RevisionDTO >> RevisionList ( long ID , bool ensureSuccessStatusCode = true ) { HttpResponseMessage obj = await client . GetAsync ( $\"/odata/{OdataItemName}/{ID}/revisions\" ); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var text = await obj . Content . ReadAsStringAsync (); var items = JsonNode . Parse ( text ) ! [ \"value\" ]. Deserialize < List < RevisionDTO >> (); return items ! ; } } Second, copy the code below and paste the whole code inside CustomWebApplicationFactory.cs . using Microsoft.AspNetCore.Hosting ; using Microsoft.AspNetCore.Mvc.Testing ; using Microsoft.EntityFrameworkCore ; using Microsoft.Extensions.Configuration ; using Microsoft.Extensions.DependencyInjection ; using Microsoft.Extensions.Hosting ; using Microsoft.IdentityModel.Tokens ; using ShiftSoftware.TypeAuth.Core ; using System.IdentityModel.Tokens.Jwt ; using System.Security.Claims ; using ToDo.API ; using ToDo.API.Data ; namespace ToDo.Test { public class CustomWebApplicationFactory < TStartup > : WebApplicationFactory < TStartup > where TStartup : class { IConfiguration config ; static string? token ; protected override IHost CreateHost ( IHostBuilder builder ) { builder . UseEnvironment ( \"Development\" ); config = new ConfigurationBuilder () . SetBasePath ( AppContext . BaseDirectory ) . AddJsonFile ( \"appsettings.json\" , false , true ) . Build (); var host = builder . Build (); host . Start (); var serviceProvider = host . Services ; using ( var scope = serviceProvider . CreateScope ()) { var scopedServices = scope . ServiceProvider ; var db = scopedServices . GetRequiredService < DB > (); db . Database . EnsureDeleted (); db . Database . EnsureCreated (); } return host ; } protected override void ConfigureClient ( HttpClient client ) { base . ConfigureClient ( client ); } protected override void ConfigureWebHost ( IWebHostBuilder builder ) { builder . ConfigureServices ( services => { var descriptor = services . SingleOrDefault ( d => d . ServiceType == typeof ( DbContextOptions < DB > )); if ( descriptor != null ) { services . Remove ( descriptor ); } services . AddDbContext < DB > ( options => { options . UseSqlServer ( config . GetConnectionString ( \"SQLServer_Test_APIs\" )); }); }); } } [CollectionDefinition(\"API Collection\")] public class DatabaseCollection : ICollectionFixture < CustomWebApplicationFactory < WebMarker >> { // This class has no code, and is never created. Its purpose is simply // to be the place to apply [CollectionDefinition] and all the // ICollectionFixture<> interfaces. } } Third, copy the code below and paste the whole code inside TestPriorityAttribute.cs . using Xunit.Abstractions ; using Xunit.Sdk ; namespace ToDo.Test { [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class TestPriorityAttribute : Attribute { public int Priority { get ; private set ; } public TestPriorityAttribute ( int priority ) => Priority = priority ; } public class PriorityOrderer : ITestCaseOrderer { public IEnumerable < TTestCase > OrderTestCases < TTestCase > ( IEnumerable < TTestCase > testCases ) where TTestCase : ITestCase { string assemblyName = typeof ( TestPriorityAttribute ). AssemblyQualifiedName ! ; var sortedMethods = new SortedDictionary < int , List < TTestCase >> (); foreach ( TTestCase testCase in testCases ) { int priority = testCase . TestMethod . Method . GetCustomAttributes ( assemblyName ) . FirstOrDefault () ?. GetNamedArgument < int > ( nameof ( TestPriorityAttribute . Priority )) ?? 0 ; GetOrCreate ( sortedMethods , priority ). Add ( testCase ); } foreach ( TTestCase testCase in sortedMethods . Keys . SelectMany ( priority => sortedMethods [ priority ]. OrderBy ( testCase => testCase . TestMethod . Method . Name ))) { yield return testCase ; } } private static TValue GetOrCreate < TKey , TValue > ( IDictionary < TKey , TValue > dictionary , TKey key ) where TKey : struct where TValue : new () => dictionary . TryGetValue ( key , out TValue ? result ) ? result : ( dictionary [ key ] = new TValue ()); } } After that, add a new item to the project and name it appsettings.json , by right-clicking on the project and selecting Add -> New Item . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Tests \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 BasicTest.cs \u2502 \u251c\u2500\u2500 CustomWebApplicationFactory.cs \u2502 \u251c\u2500\u2500 TestPriorityAttribute.cs \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web Inside the JSON file, copy the following code and paste it inside the whole file: { \"ConnectionStrings\" : { \"SQLServer_Test_APIs\" : \"Server=localhost\\\\sqlexpress;Initial Catalog=ToDo_Test_APIs;Persist Security Info=True;Integrated Security=SSPI;TrustServerCertificate=True;\" } } Writing The Tests \u00b6 Add a new class inside Tests/ToDo folder and name it Basic.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Tests \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 Basic.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 BasicTest.cs \u2502 \u251c\u2500\u2500 CustomWebApplicationFactory.cs \u2502 \u251c\u2500\u2500 TestPriorityAttribute.cs \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web First, change the internal to public . namespace ToDo.Test.Tests.ToDo ; public class Basic { } Second, Add the TestCaseOrderer and Collection . namespace ToDo.Test.Tests.ToDo ; [TestCaseOrderer(\"ToDo.Test.PriorityOrderer\", \"ToDo.Test\")] [Collection(\"API Collection\")] public class Basic { } Third, extend BasicTest and write the constructor. using ToDo.Shared.DTOs.ToDo ; using ToDo.Shared.Enums ; namespace ToDo.Test.Tests.ToDo ; [TestCaseOrderer(\"ToDo.Test.PriorityOrderer\", \"ToDo.Test\")] [Collection(\"API Collection\")] public class Basic : BasicTest < ToDoDTO , ToDoListDTO > { public Basic ( CustomWebApplicationFactory < WebMarker > factory , ITestOutputHelper output ) : base ( \"ToDo\" , \"ToDo\" , factory . CreateClient (), output ) { } } Fourth, add the following properties: using ToDo.Shared.DTOs.ToDo ; using ToDo.Shared.Enums ; namespace ToDo.Test.Tests.ToDo ; [TestCaseOrderer(\"ToDo.Test.PriorityOrderer\", \"ToDo.Test\")] [Collection(\"API Collection\")] public class Basic : BasicTest < ToDoDTO , ToDoListDTO > { static long CreatedItemId ; static string title = \"ToDo 1\" ; static string description = \"ToDo Item 1\" ; static ToDoStatus status = ToDoStatus . New ; public Basic ( CustomWebApplicationFactory < WebMarker > factory , ITestOutputHelper output ) : base ( \"ToDo\" , \"ToDo\" , factory . CreateClient (), output ) { } } Fifth, add the following method: using ToDo.Shared.DTOs.ToDo ; using ToDo.Shared.Enums ; namespace ToDo.Test.Tests.ToDo ; [TestCaseOrderer(\"ToDo.Test.PriorityOrderer\", \"ToDo.Test\")] [Collection(\"API Collection\")] public class Basic : BasicTest < ToDoDTO , ToDoListDTO > { static long CreatedItemId ; static string title = \"ToDo 1\" ; static string description = \"ToDo Item 1\" ; static ToDoStatus status = ToDoStatus . New ; public Basic ( CustomWebApplicationFactory < WebMarker > factory , ITestOutputHelper output ) : base ( \"ToDo\" , \"ToDo\" , factory . CreateClient (), output ) { } public async Task < ToDoDTO > PostOrPut ( long? ID , string title , string description , ToDoStatus status ) { var dto = new ToDoDTO { Title = title , Description = description , Status = status }; if ( ID == null ) return await base . Post ( dto ); else return await base . Put ( ID . Value , dto ); } } Finally, add these test cases: using ToDo.Shared.DTOs.ToDo ; using ToDo.Shared.Enums ; namespace ToDo.Test.Tests.ToDo ; [TestCaseOrderer(\"ToDo.Test.PriorityOrderer\", \"ToDo.Test\")] [Collection(\"API Collection\")] public class Basic : BasicTest < ToDoDTO , ToDoListDTO > { static long CreatedItemId ; static string title = \"ToDo 1\" ; static string description = \"ToDo Item 1\" ; static ToDoStatus status = ToDoStatus . New ; public Basic ( CustomWebApplicationFactory < WebMarker > factory , ITestOutputHelper output ) : base ( \"ToDo\" , \"ToDo\" , factory . CreateClient (), output ) { } public async Task < ToDoDTO > PostOrPut ( long? ID , string title , string description , ToDoStatus status ) { var dto = new ToDoDTO { Title = title , Description = description , Status = status }; if ( ID == null ) return await base . Post ( dto ); else return await base . Put ( ID . Value , dto ); } [Fact(DisplayName = \"01. Create\"), TestPriority(1)] public async Task _01_Create () { var item = await PostOrPut ( ID : null , title : title , description : description , status : status ); CreatedItemId = item . ID ; Assert . Multiple ( () => Assert . Equal ( title , item . Title ), () => Assert . Equal ( description , item . Description ), () => Assert . Equal ( status , item . Status ) ); } [Fact(DisplayName = \"02. List\"), TestPriority(2)] public async Task _02_List () { var items = await base . OdataList (); Assert . Contains ( items , x => x . Title == title ); } [Fact(DisplayName = \"03. Filter\"), TestPriority(3)] public async Task _03_Filter () { var items = await base . OdataList ( $\"?$filter=Title eq 'Random Title'\" ); Assert . DoesNotContain ( items , x => x . Title == title ); } [Fact(DisplayName = \"04. Get\"), TestPriority(4)] public async Task _04_Get () { var item = await base . Get ( CreatedItemId ); Assert . Equal ( title , item . Title ); } [Fact(DisplayName = \"05. Put\"), TestPriority(5)] public async Task _05_Put () { var updatedTitle = $\"{title} - Updated\" ; var updatedDescription = $\"{description} - Updated\" ; var updatedStatus = ToDoStatus . InProgress ; var item = await PostOrPut ( ID : CreatedItemId , title : updatedTitle , description : updatedDescription , status : updatedStatus ); CreatedItemId = item . ID ; Assert . Multiple ( () => Assert . Equal ( updatedTitle , item . Title ), () => Assert . Equal ( updatedDescription , item . Description ), () => Assert . Equal ( updatedStatus , item . Status ) ); } [Fact(DisplayName = \"07. Get Revisions\"), TestPriority(6)] public async Task _07_GetRevisions () { var revisions = await base . RevisionList ( CreatedItemId ); Assert . True ( revisions . Count > 0 ); } [Fact(DisplayName = \"07. Delete\"), TestPriority(7)] public async Task _07_Delete () { var item = await base . Delete ( CreatedItemId ); Assert . True ( item . IsDeleted ); } } Before start running the tests, right-click on appsettings.json and select Properties . Inside Properties, change the value of Copy to Output Directory to Copy Always . Now, you can run the tests by clicking on Test Explorer , then clicking on the run button.","title":"Testing"},{"location":"back-end/testing/#testing","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web","title":"Testing"},{"location":"back-end/testing/#installing-the-packages","text":"Open NuGet Package Manager and install the following two packages for the project: Microsoft.AspNetCore.Mvc.Testing Microsoft.EntityFrameworkCore","title":"Installing The Packages"},{"location":"back-end/testing/#setting-up-the-test-project-files","text":"Create a new folder inside the project and name it Tests . Inside that folder, create a new one and name it ToDo . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Tests \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web Inside Usings.cs add the following code: global using Xunit ; global using System.Text.Json ; global using ShiftSoftware.ShiftEntity.Model ; global using System.Text.Json.Nodes ; global using System.Text ; global using Xunit.Abstractions ; global using ToDo.Shared ; global using ToDo.API ; Then, go to ToDo.API Project. ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Add a new class inside the project and name it WebMarker.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web After that, go back to ToDo.Test project. ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Tests \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web Now, we will add three classes inside the project, BasicTest.CS , CustomWebApplicationFactory.cs , TestPriorityAttribute.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Tests \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u251c\u2500\u2500 BasicTest.cs \u2502 \u251c\u2500\u2500 CustomWebApplicationFactory.cs \u2502 \u251c\u2500\u2500 TestPriorityAttribute.cs \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web First, copy the code below and paste the whole code inside BasicTest.cs . using ShiftSoftware.ShiftEntity.Model.Dtos ; using ShiftSoftware.ShiftEntity.Model ; using System.Text.Json.Nodes ; using System.Text ; using Xunit.Abstractions ; namespace ToDo.Test ; public class BasicTest < DTO , ListDTO > where DTO : ShiftEntityDTO where ListDTO : ShiftEntityListDTO { public HttpClient client ; public ITestOutputHelper output ; public string ApiItemName { get ; set ; } public string OdataItemName { get ; set ; } public BasicTest ( string apiItemName , string odataItemItem , HttpClient client , ITestOutputHelper output ) { this . ApiItemName = apiItemName ; this . OdataItemName = odataItemItem ; this . client = client ; this . output = output ; } public async Task < DTO > Get ( long ID , bool ensureSuccessStatusCode = true ) { HttpResponseMessage obj = await client . GetAsync ( $\"/api/{ApiItemName}/{ID}\" ); var text = await obj . Content . ReadAsStringAsync (); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var item = JsonNode . Parse ( text ). Deserialize < ShiftEntityResponse < DTO >> (); return item ! . Entity ! ; } public async Task < DTO > Post ( DTO dto , bool ensureSuccessStatusCode = true ) { var httpContent = new StringContent ( JsonSerializer . Serialize ( dto ), Encoding . UTF8 , \"application/json\" ); HttpResponseMessage obj = await client . PostAsync ( $\"/api/{ApiItemName}\" , httpContent ); var text = await obj . Content . ReadAsStringAsync (); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var item = JsonNode . Parse ( text ). Deserialize < ShiftEntityResponse < DTO >> (); return item ! . Entity ! ; } public async Task < DTO > Put ( long ID , DTO dto , bool ensureSuccessStatusCode = true ) { var httpContent = new StringContent ( JsonSerializer . Serialize ( dto ), Encoding . UTF8 , \"application/json\" ); HttpResponseMessage obj = await client . PutAsync ( $\"/api/{ApiItemName}/{ID}\" , httpContent ); var text = await obj . Content . ReadAsStringAsync (); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var item = JsonNode . Parse ( text ). Deserialize < ShiftEntityResponse < DTO >> (); return item ! . Entity ! ; } public async Task < DTO > Delete ( long ID , bool ensureSuccessStatusCode = true ) { HttpResponseMessage obj = await client . DeleteAsync ( $\"/api/{ApiItemName}/{ID}\" ); var text = await obj . Content . ReadAsStringAsync (); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var item = JsonNode . Parse ( text ). Deserialize < ShiftEntityResponse < DTO >> (); return item ! . Entity ! ; } public async Task < List < ListDTO >> OdataList ( string? queryString = null , bool ensureSuccessStatusCode = true ) { HttpResponseMessage obj = await client . GetAsync ( $\"/odata/{OdataItemName}{queryString}\" ); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var text = await obj . Content . ReadAsStringAsync (); var items = JsonNode . Parse ( text ) ! [ \"value\" ]. Deserialize < List < ListDTO >> (); return items ! ; } public async Task < List < RevisionDTO >> RevisionList ( long ID , bool ensureSuccessStatusCode = true ) { HttpResponseMessage obj = await client . GetAsync ( $\"/odata/{OdataItemName}/{ID}/revisions\" ); if ( ensureSuccessStatusCode ) obj . EnsureSuccessStatusCode (); var text = await obj . Content . ReadAsStringAsync (); var items = JsonNode . Parse ( text ) ! [ \"value\" ]. Deserialize < List < RevisionDTO >> (); return items ! ; } } Second, copy the code below and paste the whole code inside CustomWebApplicationFactory.cs . using Microsoft.AspNetCore.Hosting ; using Microsoft.AspNetCore.Mvc.Testing ; using Microsoft.EntityFrameworkCore ; using Microsoft.Extensions.Configuration ; using Microsoft.Extensions.DependencyInjection ; using Microsoft.Extensions.Hosting ; using Microsoft.IdentityModel.Tokens ; using ShiftSoftware.TypeAuth.Core ; using System.IdentityModel.Tokens.Jwt ; using System.Security.Claims ; using ToDo.API ; using ToDo.API.Data ; namespace ToDo.Test { public class CustomWebApplicationFactory < TStartup > : WebApplicationFactory < TStartup > where TStartup : class { IConfiguration config ; static string? token ; protected override IHost CreateHost ( IHostBuilder builder ) { builder . UseEnvironment ( \"Development\" ); config = new ConfigurationBuilder () . SetBasePath ( AppContext . BaseDirectory ) . AddJsonFile ( \"appsettings.json\" , false , true ) . Build (); var host = builder . Build (); host . Start (); var serviceProvider = host . Services ; using ( var scope = serviceProvider . CreateScope ()) { var scopedServices = scope . ServiceProvider ; var db = scopedServices . GetRequiredService < DB > (); db . Database . EnsureDeleted (); db . Database . EnsureCreated (); } return host ; } protected override void ConfigureClient ( HttpClient client ) { base . ConfigureClient ( client ); } protected override void ConfigureWebHost ( IWebHostBuilder builder ) { builder . ConfigureServices ( services => { var descriptor = services . SingleOrDefault ( d => d . ServiceType == typeof ( DbContextOptions < DB > )); if ( descriptor != null ) { services . Remove ( descriptor ); } services . AddDbContext < DB > ( options => { options . UseSqlServer ( config . GetConnectionString ( \"SQLServer_Test_APIs\" )); }); }); } } [CollectionDefinition(\"API Collection\")] public class DatabaseCollection : ICollectionFixture < CustomWebApplicationFactory < WebMarker >> { // This class has no code, and is never created. Its purpose is simply // to be the place to apply [CollectionDefinition] and all the // ICollectionFixture<> interfaces. } } Third, copy the code below and paste the whole code inside TestPriorityAttribute.cs . using Xunit.Abstractions ; using Xunit.Sdk ; namespace ToDo.Test { [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class TestPriorityAttribute : Attribute { public int Priority { get ; private set ; } public TestPriorityAttribute ( int priority ) => Priority = priority ; } public class PriorityOrderer : ITestCaseOrderer { public IEnumerable < TTestCase > OrderTestCases < TTestCase > ( IEnumerable < TTestCase > testCases ) where TTestCase : ITestCase { string assemblyName = typeof ( TestPriorityAttribute ). AssemblyQualifiedName ! ; var sortedMethods = new SortedDictionary < int , List < TTestCase >> (); foreach ( TTestCase testCase in testCases ) { int priority = testCase . TestMethod . Method . GetCustomAttributes ( assemblyName ) . FirstOrDefault () ?. GetNamedArgument < int > ( nameof ( TestPriorityAttribute . Priority )) ?? 0 ; GetOrCreate ( sortedMethods , priority ). Add ( testCase ); } foreach ( TTestCase testCase in sortedMethods . Keys . SelectMany ( priority => sortedMethods [ priority ]. OrderBy ( testCase => testCase . TestMethod . Method . Name ))) { yield return testCase ; } } private static TValue GetOrCreate < TKey , TValue > ( IDictionary < TKey , TValue > dictionary , TKey key ) where TKey : struct where TValue : new () => dictionary . TryGetValue ( key , out TValue ? result ) ? result : ( dictionary [ key ] = new TValue ()); } } After that, add a new item to the project and name it appsettings.json , by right-clicking on the project and selecting Add -> New Item . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Tests \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 BasicTest.cs \u2502 \u251c\u2500\u2500 CustomWebApplicationFactory.cs \u2502 \u251c\u2500\u2500 TestPriorityAttribute.cs \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web Inside the JSON file, copy the following code and paste it inside the whole file: { \"ConnectionStrings\" : { \"SQLServer_Test_APIs\" : \"Server=localhost\\\\sqlexpress;Initial Catalog=ToDo_Test_APIs;Persist Security Info=True;Integrated Security=SSPI;TrustServerCertificate=True;\" } }","title":"Setting Up The Test Project Files"},{"location":"back-end/testing/#writing-the-tests","text":"Add a new class inside Tests/ToDo folder and name it Basic.cs . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Tests \u2502 \u2502 \u251c\u2500\u2500 ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 Basic.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 BasicTest.cs \u2502 \u251c\u2500\u2500 CustomWebApplicationFactory.cs \u2502 \u251c\u2500\u2500 TestPriorityAttribute.cs \u2502 \u251c\u2500\u2500 UnitTest1.cs \u2502 \u251c\u2500\u2500 Usings.cs \u2502 \u251c\u2500\u2500 ToDo.Web First, change the internal to public . namespace ToDo.Test.Tests.ToDo ; public class Basic { } Second, Add the TestCaseOrderer and Collection . namespace ToDo.Test.Tests.ToDo ; [TestCaseOrderer(\"ToDo.Test.PriorityOrderer\", \"ToDo.Test\")] [Collection(\"API Collection\")] public class Basic { } Third, extend BasicTest and write the constructor. using ToDo.Shared.DTOs.ToDo ; using ToDo.Shared.Enums ; namespace ToDo.Test.Tests.ToDo ; [TestCaseOrderer(\"ToDo.Test.PriorityOrderer\", \"ToDo.Test\")] [Collection(\"API Collection\")] public class Basic : BasicTest < ToDoDTO , ToDoListDTO > { public Basic ( CustomWebApplicationFactory < WebMarker > factory , ITestOutputHelper output ) : base ( \"ToDo\" , \"ToDo\" , factory . CreateClient (), output ) { } } Fourth, add the following properties: using ToDo.Shared.DTOs.ToDo ; using ToDo.Shared.Enums ; namespace ToDo.Test.Tests.ToDo ; [TestCaseOrderer(\"ToDo.Test.PriorityOrderer\", \"ToDo.Test\")] [Collection(\"API Collection\")] public class Basic : BasicTest < ToDoDTO , ToDoListDTO > { static long CreatedItemId ; static string title = \"ToDo 1\" ; static string description = \"ToDo Item 1\" ; static ToDoStatus status = ToDoStatus . New ; public Basic ( CustomWebApplicationFactory < WebMarker > factory , ITestOutputHelper output ) : base ( \"ToDo\" , \"ToDo\" , factory . CreateClient (), output ) { } } Fifth, add the following method: using ToDo.Shared.DTOs.ToDo ; using ToDo.Shared.Enums ; namespace ToDo.Test.Tests.ToDo ; [TestCaseOrderer(\"ToDo.Test.PriorityOrderer\", \"ToDo.Test\")] [Collection(\"API Collection\")] public class Basic : BasicTest < ToDoDTO , ToDoListDTO > { static long CreatedItemId ; static string title = \"ToDo 1\" ; static string description = \"ToDo Item 1\" ; static ToDoStatus status = ToDoStatus . New ; public Basic ( CustomWebApplicationFactory < WebMarker > factory , ITestOutputHelper output ) : base ( \"ToDo\" , \"ToDo\" , factory . CreateClient (), output ) { } public async Task < ToDoDTO > PostOrPut ( long? ID , string title , string description , ToDoStatus status ) { var dto = new ToDoDTO { Title = title , Description = description , Status = status }; if ( ID == null ) return await base . Post ( dto ); else return await base . Put ( ID . Value , dto ); } } Finally, add these test cases: using ToDo.Shared.DTOs.ToDo ; using ToDo.Shared.Enums ; namespace ToDo.Test.Tests.ToDo ; [TestCaseOrderer(\"ToDo.Test.PriorityOrderer\", \"ToDo.Test\")] [Collection(\"API Collection\")] public class Basic : BasicTest < ToDoDTO , ToDoListDTO > { static long CreatedItemId ; static string title = \"ToDo 1\" ; static string description = \"ToDo Item 1\" ; static ToDoStatus status = ToDoStatus . New ; public Basic ( CustomWebApplicationFactory < WebMarker > factory , ITestOutputHelper output ) : base ( \"ToDo\" , \"ToDo\" , factory . CreateClient (), output ) { } public async Task < ToDoDTO > PostOrPut ( long? ID , string title , string description , ToDoStatus status ) { var dto = new ToDoDTO { Title = title , Description = description , Status = status }; if ( ID == null ) return await base . Post ( dto ); else return await base . Put ( ID . Value , dto ); } [Fact(DisplayName = \"01. Create\"), TestPriority(1)] public async Task _01_Create () { var item = await PostOrPut ( ID : null , title : title , description : description , status : status ); CreatedItemId = item . ID ; Assert . Multiple ( () => Assert . Equal ( title , item . Title ), () => Assert . Equal ( description , item . Description ), () => Assert . Equal ( status , item . Status ) ); } [Fact(DisplayName = \"02. List\"), TestPriority(2)] public async Task _02_List () { var items = await base . OdataList (); Assert . Contains ( items , x => x . Title == title ); } [Fact(DisplayName = \"03. Filter\"), TestPriority(3)] public async Task _03_Filter () { var items = await base . OdataList ( $\"?$filter=Title eq 'Random Title'\" ); Assert . DoesNotContain ( items , x => x . Title == title ); } [Fact(DisplayName = \"04. Get\"), TestPriority(4)] public async Task _04_Get () { var item = await base . Get ( CreatedItemId ); Assert . Equal ( title , item . Title ); } [Fact(DisplayName = \"05. Put\"), TestPriority(5)] public async Task _05_Put () { var updatedTitle = $\"{title} - Updated\" ; var updatedDescription = $\"{description} - Updated\" ; var updatedStatus = ToDoStatus . InProgress ; var item = await PostOrPut ( ID : CreatedItemId , title : updatedTitle , description : updatedDescription , status : updatedStatus ); CreatedItemId = item . ID ; Assert . Multiple ( () => Assert . Equal ( updatedTitle , item . Title ), () => Assert . Equal ( updatedDescription , item . Description ), () => Assert . Equal ( updatedStatus , item . Status ) ); } [Fact(DisplayName = \"07. Get Revisions\"), TestPriority(6)] public async Task _07_GetRevisions () { var revisions = await base . RevisionList ( CreatedItemId ); Assert . True ( revisions . Count > 0 ); } [Fact(DisplayName = \"07. Delete\"), TestPriority(7)] public async Task _07_Delete () { var item = await base . Delete ( CreatedItemId ); Assert . True ( item . IsDeleted ); } } Before start running the tests, right-click on appsettings.json and select Properties . Inside Properties, change the value of Copy to Output Directory to Copy Always . Now, you can run the tests by clicking on Test Explorer , then clicking on the run button.","title":"Writing The Tests"},{"location":"back-end/deployment/production-deployment/","text":"Pushing Staging to Production \u00b6 Swapping The Application From Staging to Production \u00b6 This time if we need to publish the staging project to production, we just need to swap it using this pipeline. First, add the following code to the new pipeline. trigger : none pool : vmImage : ubuntu-latest variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true fetchTags : true fetchDepth : 10 Then, add a Bash task to fetch the latest release tag. trigger : none pool : vmImage : ubuntu-latest variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true fetchTags : true fetchDepth : 10 - task : Bash@3 displayName : 'Get Latest Release Tag' inputs : targetType : 'inline' script : echo \"##vso[task.setvariable variable=tag;]$(git describe --tags --match release-* --abbrev=0)\" After that, checkout to the commit that the release tag was pushed. trigger : none pool : vmImage : ubuntu-latest variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true fetchTags : true fetchDepth : 10 - task : Bash@3 displayName : 'Get Latest Release Tag' inputs : targetType : 'inline' script : echo \"##vso[task.setvariable variable=tag;]$(git describe --tags --match release-* --abbrev=0)\" - script : git checkout $(tag) displayName : 'Checkout Latest Release Tag' Now, install dotnet-ef and update the database. trigger : none pool : vmImage : ubuntu-latest variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true fetchTags : true fetchDepth : 10 - task : Bash@3 displayName : 'Get Latest Release Tag' inputs : targetType : 'inline' script : echo \"##vso[task.setvariable variable=tag;]$(git describe --tags --match release-* --abbrev=0)\" - script : git checkout $(tag) displayName : 'Checkout Latest Release Tag' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' Finally, add a task for swapping the slots to production. trigger : none pool : vmImage : ubuntu-latest variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true fetchTags : true fetchDepth : 10 - task : Bash@3 displayName : 'Get Latest Release Tag' inputs : targetType : 'inline' script : echo \"##vso[task.setvariable variable=tag;]$(git describe --tags --match release-* --abbrev=0)\" - script : git checkout $(tag) displayName : 'Checkout Latest Release Tag' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' - task : AzureAppServiceManage@0 inputs : azureSubscription : '<Place the Azure subscription here>' Action : 'Swap Slots' WebAppName : '<Write the name of the application here>' ResourceGroupName : '<Write the resouce group name here>' SourceSlot : 'staging'","title":"Pushing Staging to Production"},{"location":"back-end/deployment/production-deployment/#pushing-staging-to-production","text":"","title":"Pushing Staging to Production"},{"location":"back-end/deployment/production-deployment/#swapping-the-application-from-staging-to-production","text":"This time if we need to publish the staging project to production, we just need to swap it using this pipeline. First, add the following code to the new pipeline. trigger : none pool : vmImage : ubuntu-latest variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true fetchTags : true fetchDepth : 10 Then, add a Bash task to fetch the latest release tag. trigger : none pool : vmImage : ubuntu-latest variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true fetchTags : true fetchDepth : 10 - task : Bash@3 displayName : 'Get Latest Release Tag' inputs : targetType : 'inline' script : echo \"##vso[task.setvariable variable=tag;]$(git describe --tags --match release-* --abbrev=0)\" After that, checkout to the commit that the release tag was pushed. trigger : none pool : vmImage : ubuntu-latest variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true fetchTags : true fetchDepth : 10 - task : Bash@3 displayName : 'Get Latest Release Tag' inputs : targetType : 'inline' script : echo \"##vso[task.setvariable variable=tag;]$(git describe --tags --match release-* --abbrev=0)\" - script : git checkout $(tag) displayName : 'Checkout Latest Release Tag' Now, install dotnet-ef and update the database. trigger : none pool : vmImage : ubuntu-latest variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true fetchTags : true fetchDepth : 10 - task : Bash@3 displayName : 'Get Latest Release Tag' inputs : targetType : 'inline' script : echo \"##vso[task.setvariable variable=tag;]$(git describe --tags --match release-* --abbrev=0)\" - script : git checkout $(tag) displayName : 'Checkout Latest Release Tag' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' Finally, add a task for swapping the slots to production. trigger : none pool : vmImage : ubuntu-latest variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true fetchTags : true fetchDepth : 10 - task : Bash@3 displayName : 'Get Latest Release Tag' inputs : targetType : 'inline' script : echo \"##vso[task.setvariable variable=tag;]$(git describe --tags --match release-* --abbrev=0)\" - script : git checkout $(tag) displayName : 'Checkout Latest Release Tag' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' - task : AzureAppServiceManage@0 inputs : azureSubscription : '<Place the Azure subscription here>' Action : 'Swap Slots' WebAppName : '<Write the name of the application here>' ResourceGroupName : '<Write the resouce group name here>' SourceSlot : 'staging'","title":"Swapping The Application From Staging to Production"},{"location":"back-end/deployment/staging-deployment/","text":"Deploying The Application to Staging \u00b6 We will build two different pipelines, one for deploying the application on staging and one for swapping the application from staging to production. Setting Up The Pipeline \u00b6 First, We add the following code to the YAML file. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' After that, we have to define the steps of the pipeline. First step, add the following code. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true Second step is to remove the reference of the other projects with the ToDo.API project. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' Third step, removing the referenced project and its folder. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' Fourth step, we will install dotnet-ef globally. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') Fifth step, update the staging database, by providing the path to the csproj file and connection string for staging database like the following code. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') Sixth step is publishing it to artifacts. Add the following code. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet publish <Path to the csproj file> --output $(Build.ArtifactStagingDirectory) displayName : 'Publish to Artifacts' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') After that, add a task for archiving the project. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet publish <Path to the csproj file> --output $(Build.ArtifactStagingDirectory) displayName : 'Publish to Artifacts' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - task : ArchiveFiles@2 condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') inputs : rootFolderOrFile : '$(Build.ArtifactStagingDirectory)' includeRootFolder : false archiveType : 'zip' archiveFile : '$(Build.ArtifactStagingDirectory)/to-be-deployed.zip' replaceExistingArchive : true Lastly, add another task for deploying the application on Azure Web App. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet publish <Path to the csproj file> --output $(Build.ArtifactStagingDirectory) displayName : 'Publish to Artifacts' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - task : ArchiveFiles@2 condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') inputs : rootFolderOrFile : '$(Build.ArtifactStagingDirectory)' includeRootFolder : false archiveType : 'zip' archiveFile : '$(Build.ArtifactStagingDirectory)/to-be-deployed.zip' replaceExistingArchive : true - task : AzureWebApp@1 condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') inputs : azureSubscription : '<Place the Azure subscription here>' appType : 'webAppLinux' appName : '<Write the name of the application here>' deployToSlotOrASE : true resourceGroupName : '<Write the resouce group name here>' slotName : 'staging' package : '$(Build.ArtifactStagingDirectory)/to-be-deployed.zip' runtimeStack : 'DOTNETCORE|7.0'","title":"Deploying to Staging"},{"location":"back-end/deployment/staging-deployment/#deploying-the-application-to-staging","text":"We will build two different pipelines, one for deploying the application on staging and one for swapping the application from staging to production.","title":"Deploying The Application to Staging"},{"location":"back-end/deployment/staging-deployment/#setting-up-the-pipeline","text":"First, We add the following code to the YAML file. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' After that, we have to define the steps of the pipeline. First step, add the following code. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true Second step is to remove the reference of the other projects with the ToDo.API project. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' Third step, removing the referenced project and its folder. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' Fourth step, we will install dotnet-ef globally. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') Fifth step, update the staging database, by providing the path to the csproj file and connection string for staging database like the following code. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') Sixth step is publishing it to artifacts. Add the following code. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet publish <Path to the csproj file> --output $(Build.ArtifactStagingDirectory) displayName : 'Publish to Artifacts' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') After that, add a task for archiving the project. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet publish <Path to the csproj file> --output $(Build.ArtifactStagingDirectory) displayName : 'Publish to Artifacts' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - task : ArchiveFiles@2 condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') inputs : rootFolderOrFile : '$(Build.ArtifactStagingDirectory)' includeRootFolder : false archiveType : 'zip' archiveFile : '$(Build.ArtifactStagingDirectory)/to-be-deployed.zip' replaceExistingArchive : true Lastly, add another task for deploying the application on Azure Web App. # Write the name of the branch that you want to be triggered by, and to triggered when there is a release tag on the commit. trigger : branches : include : - master tags : include : - release* # Define the virtual machine you want to run this pipeline on. pool : vmImage : ubuntu-latest # Define any variable groups or variables in this section. # For variables just write: # - group: <variable group name> # # for variables: # - name: <variable name> # value: <variable value> variables : - group : pipeline - name : buildConfiguration value : 'Release' steps : - checkout : self submodules : true persistCredentials : true - script : dotnet remove <Path to the ToDo.API csproj file> reference <Path to the referenced csproj file> displayName : 'Remove <referenced project> from ToDo.API' - script : dotnet sln remove <Path to the referenced csproj file> displayName : 'Remove <Referenced project>' - script : rm -r <Path to the referenced folder> displayName : 'Remove <Referenced> folder' - script : dotnet tool install --global dotnet-ef displayName : 'Install dotnet-ef' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet ef database update --project <Path to the csproj file> --connection '<Staging database connection string>' displayName : 'Update Database' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - script : dotnet publish <Path to the csproj file> --output $(Build.ArtifactStagingDirectory) displayName : 'Publish to Artifacts' condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') - task : ArchiveFiles@2 condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') inputs : rootFolderOrFile : '$(Build.ArtifactStagingDirectory)' includeRootFolder : false archiveType : 'zip' archiveFile : '$(Build.ArtifactStagingDirectory)/to-be-deployed.zip' replaceExistingArchive : true - task : AzureWebApp@1 condition : contains(variables['Build.SourceBranch'], 'refs/tags/release') inputs : azureSubscription : '<Place the Azure subscription here>' appType : 'webAppLinux' appName : '<Write the name of the application here>' deployToSlotOrASE : true resourceGroupName : '<Write the resouce group name here>' slotName : 'staging' package : '$(Build.ArtifactStagingDirectory)/to-be-deployed.zip' runtimeStack : 'DOTNETCORE|7.0'","title":"Setting Up The Pipeline"},{"location":"back-end/printing/printing-one-todo/","text":"Printing One ToDo \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Pre-requisites \u00b6 In order to design the PDF template that we want to print, we need to install the FastReport Designer Community Edition. You can download it from this link . Using FastReport Designer \u00b6 After installing the FastReport Designer, we can start designing the template that we want to print. For the purpose of this tutorial, we will not be going into details on how to use FastReport Designer. First, open the FastReport Designer, and add a new table as the following example: ID [Task.ID] Title [Task.Title] Description [Task.Description] Status [Task.Status] Second, select all the data fields (All rows of the second column). Then, go to Preoperties -> Data and set AllowExperession to False . Third, we go to the ToDo.API project and add a new folder called Reports . Then, save the file inside that folder as Task.frx . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 Reports \u2502 \u2502 \u251c\u2500\u2500 Task.frx \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Adding One Task to Print Out \u00b6 First, go to ToDo.API -> Controllers -> ToDoController.cs . Then, add the following route to the class: using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { public ToDoController ( ToDoRepository repository ) : base ( repository ) { } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { } } } Second, find the ToDo by the ID and pass the needed attributes to a new variable called data : using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { public ToDoController ( ToDoRepository repository ) : base ( repository ) { } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { var task = await base . repository . FindAsync ( ID ); var data = new { ID = task . ID , Title = task . Title , Description = task . Description , Status = task . Status . ToDescriptionString (), }; } } } Third, return the PDF file: using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { public ToDoController ( ToDoRepository repository ) : base ( repository ) { } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { var task = await base . repository . FindAsync ( ID ); var data = new { ID = task . ID , Title = task . Title , Description = task . Description , Status = task . Status . ToDescriptionString (), }; return await new FastReportBuilder () . AddFastReportFile ( \"Reports/Task.frx\" ) . AddDataObject ( \"Task\" , data ) . GetPDFFile (); } } }","title":"Printing One ToDo"},{"location":"back-end/printing/printing-one-todo/#printing-one-todo","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web","title":"Printing One ToDo"},{"location":"back-end/printing/printing-one-todo/#pre-requisites","text":"In order to design the PDF template that we want to print, we need to install the FastReport Designer Community Edition. You can download it from this link .","title":"Pre-requisites"},{"location":"back-end/printing/printing-one-todo/#using-fastreport-designer","text":"After installing the FastReport Designer, we can start designing the template that we want to print. For the purpose of this tutorial, we will not be going into details on how to use FastReport Designer. First, open the FastReport Designer, and add a new table as the following example: ID [Task.ID] Title [Task.Title] Description [Task.Description] Status [Task.Status] Second, select all the data fields (All rows of the second column). Then, go to Preoperties -> Data and set AllowExperession to False . Third, we go to the ToDo.API project and add a new folder called Reports . Then, save the file inside that folder as Task.frx . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 Reports \u2502 \u2502 \u251c\u2500\u2500 Task.frx \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web","title":"Using FastReport Designer"},{"location":"back-end/printing/printing-one-todo/#adding-one-task-to-print-out","text":"First, go to ToDo.API -> Controllers -> ToDoController.cs . Then, add the following route to the class: using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { public ToDoController ( ToDoRepository repository ) : base ( repository ) { } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { } } } Second, find the ToDo by the ID and pass the needed attributes to a new variable called data : using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { public ToDoController ( ToDoRepository repository ) : base ( repository ) { } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { var task = await base . repository . FindAsync ( ID ); var data = new { ID = task . ID , Title = task . Title , Description = task . Description , Status = task . Status . ToDescriptionString (), }; } } } Third, return the PDF file: using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { public ToDoController ( ToDoRepository repository ) : base ( repository ) { } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { var task = await base . repository . FindAsync ( ID ); var data = new { ID = task . ID , Title = task . Title , Description = task . Description , Status = task . Status . ToDescriptionString (), }; return await new FastReportBuilder () . AddFastReportFile ( \"Reports/Task.frx\" ) . AddDataObject ( \"Task\" , data ) . GetPDFFile (); } } }","title":"Adding One Task to Print Out"},{"location":"back-end/printing/printing-todo-list/","text":"Printing a List of ToDos \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 Reports \u2502 \u2502 \u251c\u2500\u2500 Task.frx \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Editing The PDF Template \u00b6 First, open the PDF template inside FastReport Designer. Then, add a new table as the following example: ID Title Description Status [AllTasks.ID] [AllTasks.Title] [AllTasks.Description] [AllTasks.Status] Note The second row (The data fields that you want it to be repeated) need to be placed inside a Data Band . If it is not placed inside it, it will only show one row instead of a list. Second, select all the data fields (Second row of the table). Then, go to Preoperties -> Data and set AllowExperession to False . Third, select the Data Band and then go to Properties -> Design . Set (Name) to AllTasksDataBand . Editing The Print Route \u00b6 First, go to the ToDo.API -> Controllers -> ToDoController.cs file. Then, add the database to the class. ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 Reports \u2502 \u2502 \u251c\u2500\u2500 Task.frx \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoController ( ToDoRepository repository , DB db ) : base ( repository ) { this . db = db ; } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { var task = await base . repository . FindAsync ( ID ); var data = new { ID = task . ID , Title = task . Title , Description = task . Description , Status = task . Status . ToDescriptionString (), }; return await new FastReportBuilder () . AddFastReportFile ( \"Reports/Task.frx\" ) . AddDataObject ( \"Task\" , data ) . GetPDFFile (); } } } Second, fetch the list of ToDos from the database and return it inside the PDF file. using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoController ( ToDoRepository repository , DB db ) : base ( repository ) { this . db = db ; } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { var task = await base . repository . FindAsync ( ID ); var data = new { ID = task . ID , Title = task . Title , Description = task . Description , Status = task . Status . ToDescriptionString (), }; var allTasks = ( await this . db . ToDos . Where ( x => x . ID != task . ID ) . ToListAsync ()) . Select ( x => new { ID = x . ID , Title = x . Title , Description = x . Description , Status = x . Status . ToDescriptionString (), }) . ToList (); return await new FastReportBuilder () . AddFastReportFile ( \"Reports/Task.frx\" ) . AddDataObject ( \"Task\" , data ) . AddDataList ( \"AllTasks\" , \"AllTasksDataBand\" , allTasks . ToList < object > ()) . GetPDFFile (); } } }","title":"Printing List of ToDos"},{"location":"back-end/printing/printing-todo-list/#printing-a-list-of-todos","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 Reports \u2502 \u2502 \u251c\u2500\u2500 Task.frx \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web","title":"Printing a List of ToDos"},{"location":"back-end/printing/printing-todo-list/#editing-the-pdf-template","text":"First, open the PDF template inside FastReport Designer. Then, add a new table as the following example: ID Title Description Status [AllTasks.ID] [AllTasks.Title] [AllTasks.Description] [AllTasks.Status] Note The second row (The data fields that you want it to be repeated) need to be placed inside a Data Band . If it is not placed inside it, it will only show one row instead of a list. Second, select all the data fields (Second row of the table). Then, go to Preoperties -> Data and set AllowExperession to False . Third, select the Data Band and then go to Properties -> Design . Set (Name) to AllTasksDataBand .","title":"Editing The PDF Template"},{"location":"back-end/printing/printing-todo-list/#editing-the-print-route","text":"First, go to the ToDo.API -> Controllers -> ToDoController.cs file. Then, add the database to the class. ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 Reports \u2502 \u2502 \u251c\u2500\u2500 Task.frx \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoController ( ToDoRepository repository , DB db ) : base ( repository ) { this . db = db ; } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { var task = await base . repository . FindAsync ( ID ); var data = new { ID = task . ID , Title = task . Title , Description = task . Description , Status = task . Status . ToDescriptionString (), }; return await new FastReportBuilder () . AddFastReportFile ( \"Reports/Task.frx\" ) . AddDataObject ( \"Task\" , data ) . GetPDFFile (); } } } Second, fetch the list of ToDos from the database and return it inside the PDF file. using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoController ( ToDoRepository repository , DB db ) : base ( repository ) { this . db = db ; } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { var task = await base . repository . FindAsync ( ID ); var data = new { ID = task . ID , Title = task . Title , Description = task . Description , Status = task . Status . ToDescriptionString (), }; var allTasks = ( await this . db . ToDos . Where ( x => x . ID != task . ID ) . ToListAsync ()) . Select ( x => new { ID = x . ID , Title = x . Title , Description = x . Description , Status = x . Status . ToDescriptionString (), }) . ToList (); return await new FastReportBuilder () . AddFastReportFile ( \"Reports/Task.frx\" ) . AddDataObject ( \"Task\" , data ) . AddDataList ( \"AllTasks\" , \"AllTasksDataBand\" , allTasks . ToList < object > ()) . GetPDFFile (); } } }","title":"Editing The Print Route"},{"location":"back-end/printing/printing-todo-sublist/","text":"Printing a Sub List of ToDos \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 Reports \u2502 \u2502 \u251c\u2500\u2500 Task.frx \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web Editing The PDF Template \u00b6 First, open the PDF template inside FastReport Designer. Then, add a new table as the following example: [Statuses.Name] [AllTasks.ID] [AllTasks.Title] [AllTasks.Description] [AllTasks.Status] Note In order to add the sub list, when you create the column data, right-click on the Data Band (The column, in this case it is [Statuses.Name]) and select Add Detail Data Band . After that, add the row data inside the Sub Data Band Field. Second, select all the data fields. Then, go to Preoperties -> Data and set AllowExperession to False . Third, select the Data Band of the first row and then go to Properties -> Design . Set (Name) to StatusDataBand . Fourth, select the Data Band of the second row and then go to Properties -> Design . Set (Name) to AllTasksByStatusDataBand . Editing The Print Route \u00b6 Go to the ToDo.API -> Controllers -> ToDoController.cs file. ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 Reports \u2502 \u2502 \u251c\u2500\u2500 Task.frx \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web After that, fetch the statuses and return the Statuses and ToDos in the PDF file. using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoController ( ToDoRepository repository , DB db ) : base ( repository ) { this . db = db ; } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { var task = await base . repository . FindAsync ( ID ); var data = new { ID = task . ID , Title = task . Title , Description = task . Description , Status = task . Status . ToDescriptionString (), }; var allTasks = ( await this . db . ToDos . Where ( x => x . ID != task . ID ) . ToListAsync ()) . Select ( x => new { ID = x . ID , Title = x . Title , Description = x . Description , Status = x . Status . ToDescriptionString (), }) . ToList (); var statuses = allTasks . Select ( x => x . Status ). Distinct (). Select ( x => new { Name = x }). ToList (); return await new FastReportBuilder () . AddFastReportFile ( \"Reports/Task.frx\" ) . AddDataObject ( \"Task\" , data ) . AddDataList ( \"AllTasks\" , \"AllTasksDataBand\" , allTasks . ToList < object > ()) . AddDataList ( \"Statuses\" , \"StatusDataBand\" , statuses . ToList < object > ()) . AddDataList ( \"AllTasks\" , \"AllTasksByStatusDataBand\" , allTasks . ToList < object > (), 3 , \"[Statuses.Name] == [AllTasks.Status]\" ) . GetPDFFile (); } } }","title":"Printing Sub List of ToDos"},{"location":"back-end/printing/printing-todo-sublist/#printing-a-sub-list-of-todos","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 Reports \u2502 \u2502 \u251c\u2500\u2500 Task.frx \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web","title":"Printing a Sub List of ToDos"},{"location":"back-end/printing/printing-todo-sublist/#editing-the-pdf-template","text":"First, open the PDF template inside FastReport Designer. Then, add a new table as the following example: [Statuses.Name] [AllTasks.ID] [AllTasks.Title] [AllTasks.Description] [AllTasks.Status] Note In order to add the sub list, when you create the column data, right-click on the Data Band (The column, in this case it is [Statuses.Name]) and select Add Detail Data Band . After that, add the row data inside the Sub Data Band Field. Second, select all the data fields. Then, go to Preoperties -> Data and set AllowExperession to False . Third, select the Data Band of the first row and then go to Properties -> Design . Set (Name) to StatusDataBand . Fourth, select the Data Band of the second row and then go to Properties -> Design . Set (Name) to AllTasksByStatusDataBand .","title":"Editing The PDF Template"},{"location":"back-end/printing/printing-todo-sublist/#editing-the-print-route","text":"Go to the ToDo.API -> Controllers -> ToDoController.cs file. ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 Controllers \u2502 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 Reports \u2502 \u2502 \u251c\u2500\u2500 Task.frx \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 WebMarker.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web After that, fetch the statuses and return the Statuses and ToDos in the PDF file. using Microsoft.AspNetCore.Mvc ; using Microsoft.EntityFrameworkCore ; using MudBlazor.Extensions ; using ShiftSoftware.ShiftEntity.Web ; using ShiftSoftware.ShiftEntity.Web.Services ; using ToDo.API.Data ; using ToDo.API.Data.Repositories ; using ToDo.Shared.DTOs.ToDo ; namespace ToDo.API.Controllers { [Route(\"api/[controller] \")] public class ToDoController : ShiftEntityControllerAsync < ToDoRepository , Data . Entities . ToDo , ToDoListDTO , ToDoDTO > { private DB db ; public ToDoController ( ToDoRepository repository , DB db ) : base ( repository ) { this . db = db ; } [HttpGet(\"print/{ID}\")] public async Task < ActionResult > Print ( long ID ) { var task = await base . repository . FindAsync ( ID ); var data = new { ID = task . ID , Title = task . Title , Description = task . Description , Status = task . Status . ToDescriptionString (), }; var allTasks = ( await this . db . ToDos . Where ( x => x . ID != task . ID ) . ToListAsync ()) . Select ( x => new { ID = x . ID , Title = x . Title , Description = x . Description , Status = x . Status . ToDescriptionString (), }) . ToList (); var statuses = allTasks . Select ( x => x . Status ). Distinct (). Select ( x => new { Name = x }). ToList (); return await new FastReportBuilder () . AddFastReportFile ( \"Reports/Task.frx\" ) . AddDataObject ( \"Task\" , data ) . AddDataList ( \"AllTasks\" , \"AllTasksDataBand\" , allTasks . ToList < object > ()) . AddDataList ( \"Statuses\" , \"StatusDataBand\" , statuses . ToList < object > ()) . AddDataList ( \"AllTasks\" , \"AllTasksByStatusDataBand\" , allTasks . ToList < object > (), 3 , \"[Statuses.Name] == [AllTasks.Status]\" ) . GetPDFFile (); } } }","title":"Editing The Print Route"},{"location":"back-end/type-auth/introduction/","text":"Introduction to Type Auth Packages \u00b6 Type Auth packages can help in the implementation of authentication and authorization features in.NET applications. There are three packages available in Type Auth, each with a specific focus: TypeAuth.Core : This package provides a core set of functionality for handling user permissions throughout your application. It's a great starting point for any project that needs to manage user roles and permissions. TypeAuth.AspNetCore : If you're building an ASP .NET Core application, this package can help you handle authentication and authorization in a way that integrates seamlessly with the framework. It includes middleware for validating user credentials and enforcing access control. TypeAuth.Blazor : If you're using Blazor to build your UI, this package can help you manage user view permissions. It provides components that can be used to conditionally render parts of the UI based on a user's role or permissions. All three packages are available on NuGet.org and can be installed via the NuGet Package Manager in Visual Studio or using the dotnet command line tool. dotnet add package ShiftSoftware.<Write the package name that you need here>","title":"Introduction to Type Auth Packages"},{"location":"back-end/type-auth/introduction/#introduction-to-type-auth-packages","text":"Type Auth packages can help in the implementation of authentication and authorization features in.NET applications. There are three packages available in Type Auth, each with a specific focus: TypeAuth.Core : This package provides a core set of functionality for handling user permissions throughout your application. It's a great starting point for any project that needs to manage user roles and permissions. TypeAuth.AspNetCore : If you're building an ASP .NET Core application, this package can help you handle authentication and authorization in a way that integrates seamlessly with the framework. It includes middleware for validating user credentials and enforcing access control. TypeAuth.Blazor : If you're using Blazor to build your UI, this package can help you manage user view permissions. It provides components that can be used to conditionally render parts of the UI based on a user's role or permissions. All three packages are available on NuGet.org and can be installed via the NuGet Package Manager in Visual Studio or using the dotnet command line tool. dotnet add package ShiftSoftware.<Write the package name that you need here>","title":"Introduction to Type Auth Packages"},{"location":"front-end/form/","text":"Creating a Form For Working With The Data \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u2502 \u251c\u2500\u2500 _ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoList.razor \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs Adding a Form \u00b6 First, go to ToDoList.razor and add the following code: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u2502 \u251c\u2500\u2500 _ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoList.razor \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs @attribute [Route($\"/{nameof(ToDoList)}\")] @using Syncfusion.Blazor.Grids @using ToDo.Shared.DTOs.ToDo <ShiftList Action=\"/ToDo\" Title=\"ToDo List\" T=\"ToDoListDTO\" ComponentType=\"typeof(ToDoForm)\" EnablePdfExport AutoGenerateColumns=\"false\" EnableCsvExcelExport> <ColumnTemplate> <GridColumn HeaderText=\"Title\" Field=\"@nameof(ToDoListDTO.Title)\" /> <GridColumn HeaderText=\"Description\" Field=\"@nameof(ToDoListDTO.Description)\" /> </ColumnTemplate> </ShiftList> Second, create a new razor component in the _ToDo folder and name it ToDoForm.razor . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u2502 \u251c\u2500\u2500 _ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoList.razor \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoForm.razor \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs Then, inisde ToDoForm.razor file, delete the whole code and write the following code: @attribute [Route($\"/{nameof(ToDoForm)}/{{Key?}}\")] @inherits ShiftForm<ToDoForm, ToDo.Shared.DTOs.ToDo.ToDoDTO> <ShiftEntityForm @bind-Mode=\"Mode\" @bind-Value=\"TheItem\" @ref=\"FormContainer\" Action=\"ToDo\" Title=\"ToDo\" Settings=\"@FormSetting\" @bind-Key=\"@Key\" T=\"ToDo.Shared.DTOs.ToDo.ToDoDTO\"> <MudTextField ReadOnly=\"@ReadOnly\" Disabled=\"@Disabled\" OnlyValidateIfDirty=\"true\" Label=\"Title\" @bind-Value=\"TheItem.Title\" For=\"@(() => TheItem.Title)\" Immediate=\"true\" /> <MudTextField ReadOnly=\"@ReadOnly\" Disabled=\"@Disabled\" OnlyValidateIfDirty=\"true\" Immediate=\"true\" Label=\"Description\" @bind-Value=\"TheItem.Description\" For=\"@(() => TheItem.Description)\" /> <MudSelect ReadOnly=\"@ReadOnly\" Disabled=\"@Disabled\" OnlyValidateIfDirty=\"true\" T=\"ToDo.Shared.Enums.ToDoStatus\" Label=\"Status\" AnchorOrigin=\"Origin.BottomCenter\" @bind-Value=\"TheItem.Status\" For=\"@(() => TheItem.Status)\"> <MudSelectItem Value=\"@(ToDo.Shared.Enums.ToDoStatus.New)\" /> <MudSelectItem Value=\"@(ToDo.Shared.Enums.ToDoStatus.InProgress)\" /> <MudSelectItem Value=\"@(ToDo.Shared.Enums.ToDoStatus.Completed)\" /> </MudSelect> </ShiftEntityForm>","title":"Form"},{"location":"front-end/form/#creating-a-form-for-working-with-the-data","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u2502 \u251c\u2500\u2500 _ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoList.razor \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs","title":"Creating a Form For Working With The Data"},{"location":"front-end/form/#adding-a-form","text":"First, go to ToDoList.razor and add the following code: ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u2502 \u251c\u2500\u2500 _ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoList.razor \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs @attribute [Route($\"/{nameof(ToDoList)}\")] @using Syncfusion.Blazor.Grids @using ToDo.Shared.DTOs.ToDo <ShiftList Action=\"/ToDo\" Title=\"ToDo List\" T=\"ToDoListDTO\" ComponentType=\"typeof(ToDoForm)\" EnablePdfExport AutoGenerateColumns=\"false\" EnableCsvExcelExport> <ColumnTemplate> <GridColumn HeaderText=\"Title\" Field=\"@nameof(ToDoListDTO.Title)\" /> <GridColumn HeaderText=\"Description\" Field=\"@nameof(ToDoListDTO.Description)\" /> </ColumnTemplate> </ShiftList> Second, create a new razor component in the _ToDo folder and name it ToDoForm.razor . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u2502 \u251c\u2500\u2500 _ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoList.razor \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoForm.razor \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs Then, inisde ToDoForm.razor file, delete the whole code and write the following code: @attribute [Route($\"/{nameof(ToDoForm)}/{{Key?}}\")] @inherits ShiftForm<ToDoForm, ToDo.Shared.DTOs.ToDo.ToDoDTO> <ShiftEntityForm @bind-Mode=\"Mode\" @bind-Value=\"TheItem\" @ref=\"FormContainer\" Action=\"ToDo\" Title=\"ToDo\" Settings=\"@FormSetting\" @bind-Key=\"@Key\" T=\"ToDo.Shared.DTOs.ToDo.ToDoDTO\"> <MudTextField ReadOnly=\"@ReadOnly\" Disabled=\"@Disabled\" OnlyValidateIfDirty=\"true\" Label=\"Title\" @bind-Value=\"TheItem.Title\" For=\"@(() => TheItem.Title)\" Immediate=\"true\" /> <MudTextField ReadOnly=\"@ReadOnly\" Disabled=\"@Disabled\" OnlyValidateIfDirty=\"true\" Immediate=\"true\" Label=\"Description\" @bind-Value=\"TheItem.Description\" For=\"@(() => TheItem.Description)\" /> <MudSelect ReadOnly=\"@ReadOnly\" Disabled=\"@Disabled\" OnlyValidateIfDirty=\"true\" T=\"ToDo.Shared.Enums.ToDoStatus\" Label=\"Status\" AnchorOrigin=\"Origin.BottomCenter\" @bind-Value=\"TheItem.Status\" For=\"@(() => TheItem.Status)\"> <MudSelectItem Value=\"@(ToDo.Shared.Enums.ToDoStatus.New)\" /> <MudSelectItem Value=\"@(ToDo.Shared.Enums.ToDoStatus.InProgress)\" /> <MudSelectItem Value=\"@(ToDo.Shared.Enums.ToDoStatus.Completed)\" /> </MudSelect> </ShiftEntityForm>","title":"Adding a Form"},{"location":"front-end/getting-started/","text":"Getting Started with Shift Framework for Front-end Development \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 Program.cs Installing The Packages \u00b6 Open NuGet Package Manager and install ShiftSoftware.ShiftBlazor package for the project. If the search result was empty. Make sure you have ticked Include prerelease option next to the search field. Setting Up The Project \u00b6 Adding appsettings.Development.json \u00b6 First, add a new item inside wwwroot folder and name it appsettings.Development.json . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 Program.cs Inside the file, add the below code: { \"SyncfusionLicense\" : \"[Add your sync fusion license here]\" , \"BaseURL\" : \"[Add your base URL here]\" } If you want to find your base URL, follow these steps. Go to launchSettings.json inside ToDo.API/Properties . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u2502 \u251c\u2500\u2500 launchSettings.json \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web You can find the BaseURL value in the following code: { \"iisSettings\" : { \"windowsAuthentication\" : false , \"anonymousAuthentication\" : true , \"iisExpress\" : { \"applicationUrl\" : \"http://localhost:22171\" , \"sslPort\" : 0 } }, \"profiles\" : { \"http\" : { \"commandName\" : \"Project\" , \"dotnetRunMessages\" : true , \"launchBrowser\" : true , \"applicationUrl\" : \"http://localhost:5028\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" } }, \"IIS Express\" : { \"commandName\" : \"IISExpress\" , \"launchBrowser\" : true , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" } } } } Seting Up index.html \u00b6 Add the following codes to your index.html file and replace body element with the body of the example below: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" /> < title > ToDo.Web </ title > < base href = \"/\" /> < link href = \"css/app.css\" rel = \"stylesheet\" /> < link href = \"ToDo.Web.styles.css\" rel = \"stylesheet\" /> < link href = \"_content/ShiftSoftware.ShiftBlazor/main.css\" rel = \"stylesheet\" /> < link href = \"https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap\" rel = \"stylesheet\" /> < link href = \"_content/MudBlazor/MudBlazor.min.css\" rel = \"stylesheet\" /> < link href = \"_content/Syncfusion.Blazor.Themes/material.css\" rel = \"stylesheet\" /> < script src = \"_content/Syncfusion.Blazor.Core/scripts/syncfusion-blazor.min.js\" type = \"text/javascript\" ></ script > </ head > < body > < div id = \"app\" > < svg class = \"loading-progress\" > < circle r = \"40%\" cx = \"50%\" cy = \"50%\" /> < circle r = \"40%\" cx = \"50%\" cy = \"50%\" /> </ svg > < div class = \"loading-progress-text\" ></ div > </ div > < div id = \"blazor-error-ui\" > An unhandled error has occurred. < a href = \"\" class = \"reload\" > Reload </ a > < a class = \"dismiss\" > \ud83d\uddd9 </ a > </ div > < script src = \"_framework/blazor.webassembly.js\" ></ script > < script src = \"_content/MudBlazor/MudBlazor.min.js\" ></ script > < script src = \"_content/ShiftSoftware.ShiftBlazor/main.js\" ></ script > </ body > </ html > Setting Up app.css \u00b6 Go to app.css and replace the below code with the code inside the file. input-table . mud-input-control mud-select { margin : 0 !important ; } . input-table . mud-input-control > . mud-input-control-input-container > div . mud-input . mud-input-text { margin-top : 0 !important ; } . input-table . mud-input-control { margin-top : 0 !important ; } . input-table . mud-simple-table . mud-table-bordered . mud-table-container table tbody tr td { padding : 5 px !important } . grey-expansion-headers . mud-expand-panel . mud-expand-panel-header { background-color : var ( --mud-palette-table-striped ); font-size : 20 px ; } . grey-expansion-headers . mud-expand-panel . mud-expand-panel-content { padding : 16 px 24 px 16 px ; } . light-toolbar , . mud-tabs . light-toolbar . mud-tabs-toolbar { background-color : var ( --mud-palette-table-striped ); border : 1 px solid var ( --mud-palette-table-lines ); border-top-left-radius : 3 px ; border-top-right-radius : 3 px ; } . mud-tabs . light-toolbar . mud-tabs-panels { background : var ( --mud-palette-surface ); } . mud-drawer-content > . mud-navmenu . mud-nav-link . mud-icon-root : first-child + . mud-nav-link-text { transition : 0.3 s ; white-space : nowrap ; overflow : hidden ; text-overflow : ellipsis ; } . mud-drawer--closed . mud-drawer-mini > . mud-drawer-content > . mud-navmenu . mud-nav-link . mud-icon-root : first-child + . mud-nav-link-text { display : initial !important ; visibility : hidden ; opacity : 0 ; } html , body { font-family : 'Helvetica Neue' , Helvetica , Arial , sans-serif ; } h1 : focus { outline : none ; } a , . btn-link { color : #0071c1 ; } . btn-primary { color : #fff ; background-color : #1b6ec2 ; border-color : #1861ac ; } . btn : focus , . btn : active : focus , . btn-link . nav-link : focus , . form-control : focus , . form-check-input : focus { box-shadow : 0 0 0 0.1 rem white , 0 0 0 0.25 rem #258cfb ; } . content { padding-top : 1.1 rem ; } . valid . modified : not ([ type = checkbox ]) { outline : 1 px solid #26b050 ; } . invalid { outline : 1 px solid red ; } . validation-message { color : red ; } # blazor-error-ui { background : lightyellow ; bottom : 0 ; box-shadow : 0 -1 px 2 px rgba ( 0 , 0 , 0 , 0.2 ); display : none ; left : 0 ; padding : 0.6 rem 1.25 rem 0.7 rem 1.25 rem ; position : fixed ; width : 100 % ; z-index : 1000 ; } # blazor-error-ui . dismiss { cursor : pointer ; position : absolute ; right : 0.75 rem ; top : 0.5 rem ; } . blazor-error-boundary { background : url ( data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTYiIGhlaWdodD0iNDkiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIG92ZXJmbG93PSJoaWRkZW4iPjxkZWZzPjxjbGlwUGF0aCBpZD0iY2xpcDAiPjxyZWN0IHg9IjIzNSIgeT0iNTEiIHdpZHRoPSI1NiIgaGVpZ2h0PSI0OSIvPjwvY2xpcFBhdGg+PC9kZWZzPjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMCkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzUgLTUxKSI+PHBhdGggZD0iTTI2My41MDYgNTFDMjY0LjcxNyA1MSAyNjUuODEzIDUxLjQ4MzcgMjY2LjYwNiA1Mi4yNjU4TDI2Ny4wNTIgNTIuNzk4NyAyNjcuNTM5IDUzLjYyODMgMjkwLjE4NSA5Mi4xODMxIDI5MC41NDUgOTIuNzk1IDI5MC42NTYgOTIuOTk2QzI5MC44NzcgOTMuNTEzIDI5MSA5NC4wODE1IDI5MSA5NC42NzgyIDI5MSA5Ny4wNjUxIDI4OS4wMzggOTkgMjg2LjYxNyA5OUwyNDAuMzgzIDk5QzIzNy45NjMgOTkgMjM2IDk3LjA2NTEgMjM2IDk0LjY3ODIgMjM2IDk0LjM3OTkgMjM2LjAzMSA5NC4wODg2IDIzNi4wODkgOTMuODA3MkwyMzYuMzM4IDkzLjAxNjIgMjM2Ljg1OCA5Mi4xMzE0IDI1OS40NzMgNTMuNjI5NCAyNTkuOTYxIDUyLjc5ODUgMjYwLjQwNyA1Mi4yNjU4QzI2MS4yIDUxLjQ4MzcgMjYyLjI5NiA1MSAyNjMuNTA2IDUxWk0yNjMuNTg2IDY2LjAxODNDMjYwLjczNyA2Ni4wMTgzIDI1OS4zMTMgNjcuMTI0NSAyNTkuMzEzIDY5LjMzNyAyNTkuMzEzIDY5LjYxMDIgMjU5LjMzMiA2OS44NjA4IDI1OS4zNzEgNzAuMDg4N0wyNjEuNzk1IDg0LjAxNjEgMjY1LjM4IDg0LjAxNjEgMjY3LjgyMSA2OS43NDc1QzI2Ny44NiA2OS43MzA5IDI2Ny44NzkgNjkuNTg3NyAyNjcuODc5IDY5LjMxNzkgMjY3Ljg3OSA2Ny4xMTgyIDI2Ni40NDggNjYuMDE4MyAyNjMuNTg2IDY2LjAxODNaTTI2My41NzYgODYuMDU0N0MyNjEuMDQ5IDg2LjA1NDcgMjU5Ljc4NiA4Ny4zMDA1IDI1OS43ODYgODkuNzkyMSAyNTkuNzg2IDkyLjI4MzcgMjYxLjA0OSA5My41Mjk1IDI2My41NzYgOTMuNTI5NSAyNjYuMTE2IDkzLjUyOTUgMjY3LjM4NyA5Mi4yODM3IDI2Ny4zODcgODkuNzkyMSAyNjcuMzg3IDg3LjMwMDUgMjY2LjExNiA4Ni4wNTQ3IDI2My41NzYgODYuMDU0N1oiIGZpbGw9IiNGRkU1MDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48L3N2Zz4= ) no-repeat 1 rem / 1.8 rem , #b32121 ; padding : 1 rem 1 rem 1 rem 3.7 rem ; color : white ; } . blazor-error-boundary :: after { content : \"An error has occurred.\" } . loading-progress { position : relative ; display : block ; width : 8 rem ; height : 8 rem ; margin : 20 vh auto 1 rem auto ; } . loading-progress circle { fill : none ; stroke : #e0e0e0 ; stroke-width : 0.6 rem ; transform-origin : 50 % 50 % ; transform : rotate ( -90 deg ); } . loading-progress circle : last-child { stroke : #1b6ec2 ; stroke-dasharray : calc ( 3.141 * var ( --blazor-load-percentage , 0 % ) * 0.8 ), 500 % ; transition : stroke-dasharray 0.05 s ease-in-out ; } . loading-progress-text { position : absolute ; text-align : center ; font-weight : bold ; inset : calc ( 20 vh + 3.25 rem ) 0 auto 0.2 rem ; } . loading-progress-text : after { content : var ( --blazor-load-percentage-text , \"Loading\" ); } Setting Up MainLayout.razor \u00b6 First, delete MainLayout.razor inside the ToDo.Web . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 Program.cs After that, inside Shared folder, add a new razor component and name it MainLayout.razor . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs Then, write the following code inside the component: @inherits ShiftMainLayout @inject NavigationManager navigationManager <AddMudProviders/> <MudLayout> <MudAppBar> <MudIconButton Icon=\"@Icons.Material.Filled.Menu\" Color=\"Color.Inherit\" Edge=\"Edge.Start\" OnClick=\"@((e) => DrawerToggle())\" /> <MudLink Href=\"/\"><MudText Style=\"color: #fff;\">ToDo App</MudText></MudLink> <MudSpacer /> </MudAppBar> <MudDrawer @bind-Open=\"@_drawerOpen\" ClipMode=\"DrawerClipMode.Docked\" Elevation=\"1\" Variant=\"@DrawerVariant.Mini\" Breakpoint=\"Breakpoint.Lg\" OpenMiniOnHover=\"true\"> <NavMenu isDrawerOpen=\"_drawerOpen\" /> </MudDrawer> <MudMainContent> <MudContainer MaxWidth=\"MaxWidth.ExtraLarge\" Style=\"padding-block: 24px;\"> @Body </MudContainer> </MudMainContent> </MudLayout> @code { bool _drawerOpen = false; void DrawerToggle() { _drawerOpen = !_drawerOpen; } } Setting Up NavMenu.razor \u00b6 Inside Shared folder, add a new razor component and name it NavMenu.razor . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs Then, write the following code inside it: <MudNavMenu> </MudNavMenu> @code { [Parameter] public bool isDrawerOpen { get; set; } } Setting Up _Imports.razor \u00b6 Go to _Imports.razor and replace the the code inside it with the following code: @using System.Net.Http @using System.Net.Http.Json @using Microsoft.AspNetCore.Components.Forms @using Microsoft.AspNetCore.Components.Routing @using Microsoft.AspNetCore.Components.Web @using Microsoft.AspNetCore.Components.Web.Virtualization @using Microsoft.AspNetCore.Components.WebAssembly.Http @using Microsoft.JSInterop @using ToDo.Web @using ToDo.Web.Shared @using MudBlazor @using ShiftSoftware.ShiftBlazor.Components @using ShiftSoftware.ShiftBlazor.Utils Setting Up App.razor \u00b6 Go to App.razor and replace the the code inside it with the following code: <Router AppAssembly=\"@typeof(App).Assembly\"> <Found Context=\"routeData\"> <RouteView RouteData=\"@routeData\" DefaultLayout=\"@typeof(MainLayout)\" /> <FocusOnNavigate RouteData=\"@routeData\" Selector=\"h1\" /> </Found> <NotFound> <PageTitle>Not found</PageTitle> <LayoutView Layout=\"@typeof(MainLayout)\"> <p role=\"alert\">Sorry, there's nothing at this address.</p> </LayoutView> </NotFound> </Router> Setting Up Program.cs \u00b6 Inside Program.cs , replace the following line of code: using Microsoft.AspNetCore.Components.Web ; using Microsoft.AspNetCore.Components.WebAssembly.Hosting ; using ToDo.Web ; var builder = WebAssemblyHostBuilder . CreateDefault ( args ); builder . RootComponents . Add < App > ( \"#app\" ); builder . RootComponents . Add < HeadOutlet > ( \"head::after\" ); builder . Services . AddScoped ( sp => new HttpClient { BaseAddress = new Uri ( builder . HostEnvironment . BaseAddress ) }); await builder . Build (). RunAsync (); With this code: using Microsoft.AspNetCore.Components.Web ; using Microsoft.AspNetCore.Components.WebAssembly.Hosting ; using ToDo.Web ; var builder = WebAssemblyHostBuilder . CreateDefault ( args ); builder . RootComponents . Add < App > ( \"#app\" ); builder . RootComponents . Add < HeadOutlet > ( \"head::after\" ); var httpClient = new HttpClient { BaseAddress = new Uri ( builder . Configuration ! . GetValue < string > ( \"BaseURL\" ) ! ), }; builder . Services . AddScoped ( sp => httpClient ); await builder . Build (). RunAsync (); After that, add Shift Services. using Microsoft.AspNetCore.Components.Web ; using Microsoft.AspNetCore.Components.WebAssembly.Hosting ; using ShiftSoftware.ShiftBlazor.Extensions ; using ToDo.Web ; var builder = WebAssemblyHostBuilder . CreateDefault ( args ); builder . RootComponents . Add < App > ( \"#app\" ); builder . RootComponents . Add < HeadOutlet > ( \"head::after\" ); var httpClient = new HttpClient { BaseAddress = new Uri ( builder . Configuration ! . GetValue < string > ( \"BaseURL\" ) ! ), }; builder . Services . AddScoped ( sp => httpClient ); builder . Services . AddShiftServices ( config => { config . ShiftConfiguration = options => { options . BaseAddress = builder . Configuration ! . GetValue < string > ( \"BaseURL\" ) ! ; options . ApiPath = \"/api\" ; options . ODataPath = \"/odata\" ; options . UserListEndpoint = \"http://localhost\" ; }; config . SyncfusionLicense = builder . Configuration . GetValue < string > ( \"SyncfusionLicense\" ); }); await builder . Build (). RunAsync ();","title":"Getting Started"},{"location":"front-end/getting-started/#getting-started-with-shift-framework-for-front-end-development","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 Program.cs","title":"Getting Started with Shift Framework for Front-end Development"},{"location":"front-end/getting-started/#installing-the-packages","text":"Open NuGet Package Manager and install ShiftSoftware.ShiftBlazor package for the project. If the search result was empty. Make sure you have ticked Include prerelease option next to the search field.","title":"Installing The Packages"},{"location":"front-end/getting-started/#setting-up-the-project","text":"","title":"Setting Up The Project"},{"location":"front-end/getting-started/#adding-appsettingsdevelopmentjson","text":"First, add a new item inside wwwroot folder and name it appsettings.Development.json . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 Program.cs Inside the file, add the below code: { \"SyncfusionLicense\" : \"[Add your sync fusion license here]\" , \"BaseURL\" : \"[Add your base URL here]\" } If you want to find your base URL, follow these steps. Go to launchSettings.json inside ToDo.API/Properties . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u2502 \u251c\u2500\u2500 launchSettings.json \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 ToDoController.cs \u2502 \u251c\u2500\u2500 Data \u2502 \u2502 \u251c\u2500\u2500 Entities \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDo.cs \u2502 \u2502 \u251c\u2500\u2500 Repositories \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoRepository.cs \u2502 \u2502 \u251c\u2500\u2500 DB.cs \u2502 \u251c\u2500\u2500 appsettings.json \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u251c\u2500\u2500 Program.cs \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web You can find the BaseURL value in the following code: { \"iisSettings\" : { \"windowsAuthentication\" : false , \"anonymousAuthentication\" : true , \"iisExpress\" : { \"applicationUrl\" : \"http://localhost:22171\" , \"sslPort\" : 0 } }, \"profiles\" : { \"http\" : { \"commandName\" : \"Project\" , \"dotnetRunMessages\" : true , \"launchBrowser\" : true , \"applicationUrl\" : \"http://localhost:5028\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" } }, \"IIS Express\" : { \"commandName\" : \"IISExpress\" , \"launchBrowser\" : true , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" } } } }","title":"Adding appsettings.Development.json"},{"location":"front-end/getting-started/#seting-up-indexhtml","text":"Add the following codes to your index.html file and replace body element with the body of the example below: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" /> < title > ToDo.Web </ title > < base href = \"/\" /> < link href = \"css/app.css\" rel = \"stylesheet\" /> < link href = \"ToDo.Web.styles.css\" rel = \"stylesheet\" /> < link href = \"_content/ShiftSoftware.ShiftBlazor/main.css\" rel = \"stylesheet\" /> < link href = \"https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap\" rel = \"stylesheet\" /> < link href = \"_content/MudBlazor/MudBlazor.min.css\" rel = \"stylesheet\" /> < link href = \"_content/Syncfusion.Blazor.Themes/material.css\" rel = \"stylesheet\" /> < script src = \"_content/Syncfusion.Blazor.Core/scripts/syncfusion-blazor.min.js\" type = \"text/javascript\" ></ script > </ head > < body > < div id = \"app\" > < svg class = \"loading-progress\" > < circle r = \"40%\" cx = \"50%\" cy = \"50%\" /> < circle r = \"40%\" cx = \"50%\" cy = \"50%\" /> </ svg > < div class = \"loading-progress-text\" ></ div > </ div > < div id = \"blazor-error-ui\" > An unhandled error has occurred. < a href = \"\" class = \"reload\" > Reload </ a > < a class = \"dismiss\" > \ud83d\uddd9 </ a > </ div > < script src = \"_framework/blazor.webassembly.js\" ></ script > < script src = \"_content/MudBlazor/MudBlazor.min.js\" ></ script > < script src = \"_content/ShiftSoftware.ShiftBlazor/main.js\" ></ script > </ body > </ html >","title":"Seting Up index.html"},{"location":"front-end/getting-started/#setting-up-appcss","text":"Go to app.css and replace the below code with the code inside the file. input-table . mud-input-control mud-select { margin : 0 !important ; } . input-table . mud-input-control > . mud-input-control-input-container > div . mud-input . mud-input-text { margin-top : 0 !important ; } . input-table . mud-input-control { margin-top : 0 !important ; } . input-table . mud-simple-table . mud-table-bordered . mud-table-container table tbody tr td { padding : 5 px !important } . grey-expansion-headers . mud-expand-panel . mud-expand-panel-header { background-color : var ( --mud-palette-table-striped ); font-size : 20 px ; } . grey-expansion-headers . mud-expand-panel . mud-expand-panel-content { padding : 16 px 24 px 16 px ; } . light-toolbar , . mud-tabs . light-toolbar . mud-tabs-toolbar { background-color : var ( --mud-palette-table-striped ); border : 1 px solid var ( --mud-palette-table-lines ); border-top-left-radius : 3 px ; border-top-right-radius : 3 px ; } . mud-tabs . light-toolbar . mud-tabs-panels { background : var ( --mud-palette-surface ); } . mud-drawer-content > . mud-navmenu . mud-nav-link . mud-icon-root : first-child + . mud-nav-link-text { transition : 0.3 s ; white-space : nowrap ; overflow : hidden ; text-overflow : ellipsis ; } . mud-drawer--closed . mud-drawer-mini > . mud-drawer-content > . mud-navmenu . mud-nav-link . mud-icon-root : first-child + . mud-nav-link-text { display : initial !important ; visibility : hidden ; opacity : 0 ; } html , body { font-family : 'Helvetica Neue' , Helvetica , Arial , sans-serif ; } h1 : focus { outline : none ; } a , . btn-link { color : #0071c1 ; } . btn-primary { color : #fff ; background-color : #1b6ec2 ; border-color : #1861ac ; } . btn : focus , . btn : active : focus , . btn-link . nav-link : focus , . form-control : focus , . form-check-input : focus { box-shadow : 0 0 0 0.1 rem white , 0 0 0 0.25 rem #258cfb ; } . content { padding-top : 1.1 rem ; } . valid . modified : not ([ type = checkbox ]) { outline : 1 px solid #26b050 ; } . invalid { outline : 1 px solid red ; } . validation-message { color : red ; } # blazor-error-ui { background : lightyellow ; bottom : 0 ; box-shadow : 0 -1 px 2 px rgba ( 0 , 0 , 0 , 0.2 ); display : none ; left : 0 ; padding : 0.6 rem 1.25 rem 0.7 rem 1.25 rem ; position : fixed ; width : 100 % ; z-index : 1000 ; } # blazor-error-ui . dismiss { cursor : pointer ; position : absolute ; right : 0.75 rem ; top : 0.5 rem ; } . blazor-error-boundary { background : url ( data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTYiIGhlaWdodD0iNDkiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIG92ZXJmbG93PSJoaWRkZW4iPjxkZWZzPjxjbGlwUGF0aCBpZD0iY2xpcDAiPjxyZWN0IHg9IjIzNSIgeT0iNTEiIHdpZHRoPSI1NiIgaGVpZ2h0PSI0OSIvPjwvY2xpcFBhdGg+PC9kZWZzPjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMCkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzUgLTUxKSI+PHBhdGggZD0iTTI2My41MDYgNTFDMjY0LjcxNyA1MSAyNjUuODEzIDUxLjQ4MzcgMjY2LjYwNiA1Mi4yNjU4TDI2Ny4wNTIgNTIuNzk4NyAyNjcuNTM5IDUzLjYyODMgMjkwLjE4NSA5Mi4xODMxIDI5MC41NDUgOTIuNzk1IDI5MC42NTYgOTIuOTk2QzI5MC44NzcgOTMuNTEzIDI5MSA5NC4wODE1IDI5MSA5NC42NzgyIDI5MSA5Ny4wNjUxIDI4OS4wMzggOTkgMjg2LjYxNyA5OUwyNDAuMzgzIDk5QzIzNy45NjMgOTkgMjM2IDk3LjA2NTEgMjM2IDk0LjY3ODIgMjM2IDk0LjM3OTkgMjM2LjAzMSA5NC4wODg2IDIzNi4wODkgOTMuODA3MkwyMzYuMzM4IDkzLjAxNjIgMjM2Ljg1OCA5Mi4xMzE0IDI1OS40NzMgNTMuNjI5NCAyNTkuOTYxIDUyLjc5ODUgMjYwLjQwNyA1Mi4yNjU4QzI2MS4yIDUxLjQ4MzcgMjYyLjI5NiA1MSAyNjMuNTA2IDUxWk0yNjMuNTg2IDY2LjAxODNDMjYwLjczNyA2Ni4wMTgzIDI1OS4zMTMgNjcuMTI0NSAyNTkuMzEzIDY5LjMzNyAyNTkuMzEzIDY5LjYxMDIgMjU5LjMzMiA2OS44NjA4IDI1OS4zNzEgNzAuMDg4N0wyNjEuNzk1IDg0LjAxNjEgMjY1LjM4IDg0LjAxNjEgMjY3LjgyMSA2OS43NDc1QzI2Ny44NiA2OS43MzA5IDI2Ny44NzkgNjkuNTg3NyAyNjcuODc5IDY5LjMxNzkgMjY3Ljg3OSA2Ny4xMTgyIDI2Ni40NDggNjYuMDE4MyAyNjMuNTg2IDY2LjAxODNaTTI2My41NzYgODYuMDU0N0MyNjEuMDQ5IDg2LjA1NDcgMjU5Ljc4NiA4Ny4zMDA1IDI1OS43ODYgODkuNzkyMSAyNTkuNzg2IDkyLjI4MzcgMjYxLjA0OSA5My41Mjk1IDI2My41NzYgOTMuNTI5NSAyNjYuMTE2IDkzLjUyOTUgMjY3LjM4NyA5Mi4yODM3IDI2Ny4zODcgODkuNzkyMSAyNjcuMzg3IDg3LjMwMDUgMjY2LjExNiA4Ni4wNTQ3IDI2My41NzYgODYuMDU0N1oiIGZpbGw9IiNGRkU1MDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48L3N2Zz4= ) no-repeat 1 rem / 1.8 rem , #b32121 ; padding : 1 rem 1 rem 1 rem 3.7 rem ; color : white ; } . blazor-error-boundary :: after { content : \"An error has occurred.\" } . loading-progress { position : relative ; display : block ; width : 8 rem ; height : 8 rem ; margin : 20 vh auto 1 rem auto ; } . loading-progress circle { fill : none ; stroke : #e0e0e0 ; stroke-width : 0.6 rem ; transform-origin : 50 % 50 % ; transform : rotate ( -90 deg ); } . loading-progress circle : last-child { stroke : #1b6ec2 ; stroke-dasharray : calc ( 3.141 * var ( --blazor-load-percentage , 0 % ) * 0.8 ), 500 % ; transition : stroke-dasharray 0.05 s ease-in-out ; } . loading-progress-text { position : absolute ; text-align : center ; font-weight : bold ; inset : calc ( 20 vh + 3.25 rem ) 0 auto 0.2 rem ; } . loading-progress-text : after { content : var ( --blazor-load-percentage-text , \"Loading\" ); }","title":"Setting Up app.css"},{"location":"front-end/getting-started/#setting-up-mainlayoutrazor","text":"First, delete MainLayout.razor inside the ToDo.Web . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 Program.cs After that, inside Shared folder, add a new razor component and name it MainLayout.razor . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs Then, write the following code inside the component: @inherits ShiftMainLayout @inject NavigationManager navigationManager <AddMudProviders/> <MudLayout> <MudAppBar> <MudIconButton Icon=\"@Icons.Material.Filled.Menu\" Color=\"Color.Inherit\" Edge=\"Edge.Start\" OnClick=\"@((e) => DrawerToggle())\" /> <MudLink Href=\"/\"><MudText Style=\"color: #fff;\">ToDo App</MudText></MudLink> <MudSpacer /> </MudAppBar> <MudDrawer @bind-Open=\"@_drawerOpen\" ClipMode=\"DrawerClipMode.Docked\" Elevation=\"1\" Variant=\"@DrawerVariant.Mini\" Breakpoint=\"Breakpoint.Lg\" OpenMiniOnHover=\"true\"> <NavMenu isDrawerOpen=\"_drawerOpen\" /> </MudDrawer> <MudMainContent> <MudContainer MaxWidth=\"MaxWidth.ExtraLarge\" Style=\"padding-block: 24px;\"> @Body </MudContainer> </MudMainContent> </MudLayout> @code { bool _drawerOpen = false; void DrawerToggle() { _drawerOpen = !_drawerOpen; } }","title":"Setting Up MainLayout.razor"},{"location":"front-end/getting-started/#setting-up-navmenurazor","text":"Inside Shared folder, add a new razor component and name it NavMenu.razor . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs Then, write the following code inside it: <MudNavMenu> </MudNavMenu> @code { [Parameter] public bool isDrawerOpen { get; set; } }","title":"Setting Up NavMenu.razor"},{"location":"front-end/getting-started/#setting-up-_importsrazor","text":"Go to _Imports.razor and replace the the code inside it with the following code: @using System.Net.Http @using System.Net.Http.Json @using Microsoft.AspNetCore.Components.Forms @using Microsoft.AspNetCore.Components.Routing @using Microsoft.AspNetCore.Components.Web @using Microsoft.AspNetCore.Components.Web.Virtualization @using Microsoft.AspNetCore.Components.WebAssembly.Http @using Microsoft.JSInterop @using ToDo.Web @using ToDo.Web.Shared @using MudBlazor @using ShiftSoftware.ShiftBlazor.Components @using ShiftSoftware.ShiftBlazor.Utils","title":"Setting Up _Imports.razor"},{"location":"front-end/getting-started/#setting-up-apprazor","text":"Go to App.razor and replace the the code inside it with the following code: <Router AppAssembly=\"@typeof(App).Assembly\"> <Found Context=\"routeData\"> <RouteView RouteData=\"@routeData\" DefaultLayout=\"@typeof(MainLayout)\" /> <FocusOnNavigate RouteData=\"@routeData\" Selector=\"h1\" /> </Found> <NotFound> <PageTitle>Not found</PageTitle> <LayoutView Layout=\"@typeof(MainLayout)\"> <p role=\"alert\">Sorry, there's nothing at this address.</p> </LayoutView> </NotFound> </Router>","title":"Setting Up App.razor"},{"location":"front-end/getting-started/#setting-up-programcs","text":"Inside Program.cs , replace the following line of code: using Microsoft.AspNetCore.Components.Web ; using Microsoft.AspNetCore.Components.WebAssembly.Hosting ; using ToDo.Web ; var builder = WebAssemblyHostBuilder . CreateDefault ( args ); builder . RootComponents . Add < App > ( \"#app\" ); builder . RootComponents . Add < HeadOutlet > ( \"head::after\" ); builder . Services . AddScoped ( sp => new HttpClient { BaseAddress = new Uri ( builder . HostEnvironment . BaseAddress ) }); await builder . Build (). RunAsync (); With this code: using Microsoft.AspNetCore.Components.Web ; using Microsoft.AspNetCore.Components.WebAssembly.Hosting ; using ToDo.Web ; var builder = WebAssemblyHostBuilder . CreateDefault ( args ); builder . RootComponents . Add < App > ( \"#app\" ); builder . RootComponents . Add < HeadOutlet > ( \"head::after\" ); var httpClient = new HttpClient { BaseAddress = new Uri ( builder . Configuration ! . GetValue < string > ( \"BaseURL\" ) ! ), }; builder . Services . AddScoped ( sp => httpClient ); await builder . Build (). RunAsync (); After that, add Shift Services. using Microsoft.AspNetCore.Components.Web ; using Microsoft.AspNetCore.Components.WebAssembly.Hosting ; using ShiftSoftware.ShiftBlazor.Extensions ; using ToDo.Web ; var builder = WebAssemblyHostBuilder . CreateDefault ( args ); builder . RootComponents . Add < App > ( \"#app\" ); builder . RootComponents . Add < HeadOutlet > ( \"head::after\" ); var httpClient = new HttpClient { BaseAddress = new Uri ( builder . Configuration ! . GetValue < string > ( \"BaseURL\" ) ! ), }; builder . Services . AddScoped ( sp => httpClient ); builder . Services . AddShiftServices ( config => { config . ShiftConfiguration = options => { options . BaseAddress = builder . Configuration ! . GetValue < string > ( \"BaseURL\" ) ! ; options . ApiPath = \"/api\" ; options . ODataPath = \"/odata\" ; options . UserListEndpoint = \"http://localhost\" ; }; config . SyncfusionLicense = builder . Configuration . GetValue < string > ( \"SyncfusionLicense\" ); }); await builder . Build (). RunAsync ();","title":"Setting Up Program.cs"},{"location":"front-end/list/","text":"Creating a List to Show Our ToDos \u00b6 ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs Add Navigation Button to New Page \u00b6 First, create a new folder inside Pages folder, and name it _ToDo . After that, create a new razor component in the folder and name it ToDoList.razor . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u2502 \u251c\u2500\u2500 _ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoList.razor \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs Then, go inside NavMenu.razor and add the below codes: @using ToDo.Web.Pages._ToDo; <MudNavMenu> <MudNavLink Href=\"@($\"/{nameof(ToDoList)}\")\" Match=\"NavLinkMatch.All\" Icon=\"@Icons.Material.Outlined.Task\">To Do</MudNavLink> </MudNavMenu> @code { [Parameter] public bool isDrawerOpen { get; set; } } Adding ShiftList \u00b6 Inisde ToDoList.razor file, delete the whole code and write the following code: @attribute [Route($\"/{nameof(ToDoList)}\")] @using Syncfusion.Blazor.Grids @using ToDo.Shared.DTOs.ToDo <ShiftList Action=\"/ToDo\" Title=\"ToDo List\" T=\"ToDoListDTO\" EnablePdfExport AutoGenerateColumns=\"false\" EnableCsvExcelExport> <ColumnTemplate> <GridColumn HeaderText=\"Title\" Field=\"@nameof(ToDoListDTO.Title)\" /> <GridColumn HeaderText=\"Description\" Field=\"@nameof(ToDoListDTO.Description)\" /> </ColumnTemplate> </ShiftList>","title":"List"},{"location":"front-end/list/#creating-a-list-to-show-our-todos","text":"ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs","title":"Creating a List to Show Our ToDos"},{"location":"front-end/list/#add-navigation-button-to-new-page","text":"First, create a new folder inside Pages folder, and name it _ToDo . After that, create a new razor component in the folder and name it ToDoList.razor . ToDo \u251c\u2500\u2500 ToDo.API \u2502 \u251c\u2500\u2500 ToDo.Shared \u2502 \u251c\u2500\u2500 ToDo.Test \u2502 \u251c\u2500\u2500 ToDo.Web \u2502 \u251c\u2500\u2500 Connected Services \u2502 \u251c\u2500\u2500 Dependencies \u2502 \u251c\u2500\u2500 Properties \u2502 \u251c\u2500\u2500 wwwroot \u2502 \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 appsettings.Development.json \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 Pages \u2502 \u2502 \u251c\u2500\u2500 _ToDo \u2502 \u2502 \u2502 \u251c\u2500\u2500 ToDoList.razor \u2502 \u251c\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Shared \u2502 \u2502 \u251c\u2500\u2500 MainLayout.razor \u2502 \u2502 \u251c\u2500\u2500 NavMenu.razor \u2502 \u251c\u2500\u2500 _Imports.razor \u2502 \u251c\u2500\u2500 App.razor \u2502 \u251c\u2500\u2500 Program.cs Then, go inside NavMenu.razor and add the below codes: @using ToDo.Web.Pages._ToDo; <MudNavMenu> <MudNavLink Href=\"@($\"/{nameof(ToDoList)}\")\" Match=\"NavLinkMatch.All\" Icon=\"@Icons.Material.Outlined.Task\">To Do</MudNavLink> </MudNavMenu> @code { [Parameter] public bool isDrawerOpen { get; set; } }","title":"Add Navigation Button to New Page"},{"location":"front-end/list/#adding-shiftlist","text":"Inisde ToDoList.razor file, delete the whole code and write the following code: @attribute [Route($\"/{nameof(ToDoList)}\")] @using Syncfusion.Blazor.Grids @using ToDo.Shared.DTOs.ToDo <ShiftList Action=\"/ToDo\" Title=\"ToDo List\" T=\"ToDoListDTO\" EnablePdfExport AutoGenerateColumns=\"false\" EnableCsvExcelExport> <ColumnTemplate> <GridColumn HeaderText=\"Title\" Field=\"@nameof(ToDoListDTO.Title)\" /> <GridColumn HeaderText=\"Description\" Field=\"@nameof(ToDoListDTO.Description)\" /> </ColumnTemplate> </ShiftList>","title":"Adding ShiftList"}]}